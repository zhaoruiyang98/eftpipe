from __future__ import annotations
import json
import os
import numpy as np
from cobaya.log import HasLogger
from numpy import pi, log, exp, newaxis
from scipy import special
from scipy.interpolate import interp1d
from scipy.special import legendre, j1, spherical_jn, loggamma
from scipy.integrate import quad
from pathlib import Path
from typing import Any, cast, Iterable, Protocol, TYPE_CHECKING, Union

# local
from .fftlog import FFTLog
from .resumfactor import Qawithhex
from ..tools import is_main_process
from ..tools import replace_suffix
from ..tools import root_only

if TYPE_CHECKING:
    from numpy.typing import NDArray


def cH(Om, a):
    """LCDM growth rate auxiliary function"""
    return np.sqrt(Om / a + a**2 * (1 - Om))


def DgN(Om, a):
    """LCDM growth rate auxiliary function"""
    return 5.0 / 2 * Om * cH(Om, a) / a * quad(lambda x: cH(Om, x) ** -3, 0, a)[0]


def fN(Om, z):
    """LCDM growth rate"""
    a = 1.0 / (1.0 + z)
    return (Om * (5 * a - 3 * DgN(Om, a))) / (
        2.0 * (a**3 * (1 - Om) + Om) * DgN(Om, a)
    )


def Hubble(Om, z):
    """LCDM AP parameter auxiliary function"""
    return ((Om) * (1 + z) ** 3.0 + (1 - Om)) ** 0.5


def DAfunc(Om, z):
    """LCDM AP parameter auxiliary function"""
    r = quad(lambda x: 1.0 / Hubble(Om, x), 0, z)[0]
    return r / (1 + z)


def W2D(x):
    """Fiber collision effective window method auxiliary function"""
    return (2.0 * j1(x)) / x


def Hllp(l, lp, x):
    """Fiber collision effective window method auxiliary function"""
    if l == 2 and lp == 0:
        return x**2 - 1.0
    if l == 4 and lp == 0:
        return 1.75 * x**4 - 2.5 * x**2 + 0.75
    if l == 4 and lp == 2:
        return x**4 - x**2
    if l == 6 and lp == 0:
        return 4.125 * x**6 - 7.875 * x**4 + 4.375 * x**2 - 0.625
    if l == 6 and lp == 2:
        return 2.75 * x**6 - 4.5 * x**4 + 7.0 / 4.0 * x**2
    if l == 6 and lp == 4:
        return x**6 - x**4
    else:
        return x * 0.0


def fllp_IR(l, lp, k, q, Dfc):
    """Fiber collision effective window method auxiliary function"""
    # IR q < k
    # q is an array, k is a scalar
    if l == lp:
        return (q / k) * W2D(q * Dfc) * (q / k) ** l
    else:
        return (
            (q / k)
            * W2D(q * Dfc)
            * (2.0 * l + 1.0)
            / 2.0
            * Hllp(max(l, lp), min(l, lp), q / k)
        )


def fllp_UV(l, lp, k, q, Dfc):
    """Fiber collision effective window method auxiliary function"""
    # UV q > k
    # q is an array, k is a scalar
    if l == lp:
        return W2D(q * Dfc) * (k / q) ** l
    else:
        return (
            W2D(q * Dfc) * (2.0 * l + 1.0) / 2.0 * Hllp(max(l, lp), min(l, lp), k / q)
        )


# powers of mu to Legendre polynomials
mu = {
    0: {0: 1.0, 2: 0.0, 4: 0.0},
    2: {0: 1.0 / 3.0, 2: 2.0 / 3.0, 4: 0.0},
    4: {0: 1.0 / 5.0, 2: 4.0 / 7.0, 4: 8.0 / 35.0},
    6: {0: 1.0 / 7.0, 2: 10.0 / 21.0, 4: 24.0 / 77.0},
    8: {0: 1.0 / 9.0, 2: 40.0 / 99.0, 4: 48.0 / 148.0},
}

# specific part of the 13-loop matrices
M13b = {
    0: lambda n1: 1.125,
    1: lambda n1: -(1 / (1 + n1)),
    2: lambda n1: 2.25,
    3: lambda n1: (3 * (-1 + 3 * n1)) / (4.0 * (1 + n1)),
    4: lambda n1: -(1 / (1 + n1)),
    5: lambda n1: -9 / (4 + 4 * n1),
    6: lambda n1: (9 + 18 * n1) / (4 + 4 * n1),
    7: lambda n1: (3 * (-5 + 3 * n1)) / (8.0 * (1 + n1)),
    8: lambda n1: -9 / (4 + 4 * n1),
    9: lambda n1: (9 * n1) / (4 + 4 * n1),
}


def M13a(n1):
    """Common part of the 13-loop matrices"""
    return np.tan(n1 * pi) / (14.0 * (-3 + n1) * (-2 + n1) * (-1 + n1) * n1 * pi)


# fmt: off
# specific part of the 22-loop matrices
M22b = {
    0: lambda n1, n2: (6 + n1**4 * (4 - 24 * n2) - 7 * n2 + 8 * n1**5 * n2 - 13 * n2**2 + 4 * n2**3 + 4 * n2**4 + n1**2 * (-13 + 38 * n2 + 12 * n2**2 - 8 * n2**3) + 2 * n1**3 * (2 - 5 * n2 - 4 * n2**2 + 8 * n2**3) + n1 * (-7 - 6 * n2 + 38 * n2**2 - 10 * n2**3 - 24 * n2**4 + 8 * n2**5)) / (4. * n1 * (1 + n1) * (-1 + 2 * n1) * n2 * (1 + n2) * (-1 + 2 * n2)),
    1: lambda n1, n2: (-18 + n1**2 * (1 - 11 * n2) - 12 * n2 + n2**2 + 10 * n2**3 + 2 * n1**3 * (5 + 7 * n2) + n1 * (-12 - 38 * n2 - 11 * n2**2 + 14 * n2**3)) / (7. * n1 * (1 + n1) * n2 * (1 + n2)),
    2: lambda n1, n2: (-3 * n1 + 2 * n1**2 + n2 * (-3 + 2 * n2)) / (n1 * n2),
    3: lambda n1, n2: (-4 * (-24 + n2 + 10 * n2**2) + 2 * n1 * (-2 + 51 * n2 + 21 * n2**2) + n1**2 * (-40 + 42 * n2 + 98 * n2**2)) / (49. * n1 * (1 + n1) * n2 * (1 + n2)),
    4: lambda n1, n2: (4 * (3 - 2 * n2 + n1 * (-2 + 7 * n2))) / (7. * n1 * n2),
    5: lambda n1, n2: 2,
    6: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-2 + 3 * n2 + 4 * n1**4 * n2 + 3 * n2**2 - 2 * n2**3 + n1**3 * (-2 - 2 * n2 + 4 * n2**2) + n1**2 * (3 - 10 * n2 - 4 * n2**2 + 4 * n2**3) + n1 * (3 + 2 * n2 - 10 * n2**2 - 2 * n2**3 + 4 * n2**4))) / (2. * n1 * (1 + n1) * (-1 + 2 * n1) * n2 * (1 + n2) * (-1 + 2 * n2)),
    7: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (2 + 4 * n2 + 5 * n2**2 + n1**2 * (5 + 7 * n2) + n1 * (4 + 10 * n2 + 7 * n2**2))) / (7. * n1 * (1 + n1) * n2 * (1 + n2)),
    8: lambda n1, n2: ((n1 + n2) * (-3 + 2 * n1 + 2 * n2)) / (n1 * n2),
    9: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (10 - 23 * n2 + 28 * n1**4 * n2 + 5 * n2**2 + 2 * n2**3 + n1**3 * (2 - 46 * n2 + 28 * n2**2) + n1**2 * (5 - 38 * n2 - 28 * n2**2 + 28 * n2**3) + n1 * (-23 + 94 * n2 - 38 * n2**2 - 46 * n2**3 + 28 * n2**4))) / (14. * n1 * (1 + n1) * (-1 + 2 * n1) * n2 * (1 + n2) * (-1 + 2 * n2)),
    10: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-58 + 4 * n2 + 35 * n2**2 + 7 * n1**2 * (5 + 7 * n2) + n1 * (4 + 14 * n2 + 49 * n2**2))) / (49. * n1 * (1 + n1) * n2 * (1 + n2)),
    11: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-8 + 7 * n1 + 7 * n2)) / (7. * n1 * n2),
    12: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2) * (2 + 2 * n1**3 - n2 - n2**2 + 2 * n2**3 - n1**2 * (1 + 2 * n2) - n1 * (1 + 2 * n2 + 2 * n2**2))) / (8. * n1 * (1 + n1) * (-1 + 2 * n1) * n2 * (1 + n2) * (-1 + 2 * n2)),
    13: lambda n1, n2: ((1 + n1 + n2) * (2 + n1 + n2) * (-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2)) / (8. * n1 * (1 + n1) * n2 * (1 + n2)),
    14: lambda n1, n2: -((-3 + 2 * n1 + 2 * n2) * (-6 - n1 + 2 * n1**2 - n2 + 2 * n2**2)) / (8. * n1 * (1 + n1) * n2 * (1 + n2)),
    15: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2) * (38 + 41 * n2 + 112 * n1**3 * n2 - 66 * n2**2 + 2 * n1**2 * (-33 - 18 * n2 + 56 * n2**2) + n1 * (41 - 232 * n2 - 36 * n2**2 + 112 * n2**3))) / (56. * n1 * (1 + n1) * (-1 + 2 * n1) * n2 * (1 + n2) * (-1 + 2 * n2)),
    16: lambda n1, n2: -((-3 + 2 * n1 + 2 * n2) * (9 + 3 * n1 + 3 * n2 + 7 * n1 * n2)) / (14. * n1 * (1 + n1) * n2 * (1 + n2)),
    17: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2) * (5 + 5 * n1 + 5 * n2 + 7 * n1 * n2)) / (14. * n1 * (1 + n1) * n2 * (1 + n2)),
    18: lambda n1, n2: (3 - 2 * n1 - 2 * n2) / (2. * n1 * n2),
    19: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2)) / (2. * n1 * n2),
    20: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2) * (50 - 9 * n2 + 98 * n1**3 * n2 - 35 * n2**2 + 7 * n1**2 * (-5 - 18 * n2 + 28 * n2**2) + n1 * (-9 - 66 * n2 - 126 * n2**2 + 98 * n2**3))) / (196. * n1 * (1 + n1) * (-1 + 2 * n1) * n2 * (1 + n2) * (-1 + 2 * n2)),
    21: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2) * (2 + n1 + 4 * n1**3 + n2 - 8 * n1 * n2 - 8 * n1**2 * n2 - 8 * n1 * n2**2 + 4 * n2**3)) / (8. * n1 * (1 + n1) * (-1 + 2 * n1) * n2 * (1 + n2) * (-1 + 2 * n2)),
    22: lambda n1, n2: ((2 + n1 + n2) * (-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2) * (1 + 2 * n1 + 2 * n2)) / (8. * n1 * (1 + n1) * n2 * (1 + n2)),
    23: lambda n1, n2: -((-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2) * (-2 + 7 * n1 + 7 * n2)) / (56. * n1 * (1 + n1) * n2 * (1 + n2)),
    24: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2) * (26 + 9 * n2 + 56 * n1**3 * n2 - 38 * n2**2 + 2 * n1**2 * (-19 - 18 * n2 + 56 * n2**2) + n1 * (9 - 84 * n2 - 36 * n2**2 + 56 * n2**3))) / (56. * n1 * (1 + n1) * (-1 + 2 * n1) * n2 * (1 + n2) * (-1 + 2 * n2)),
    25: lambda n1, n2: (3 * (-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2)) / (32. * n1 * (1 + n1) * n2 * (1 + n2)),
    26: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2) * (1 + 2 * n1 + 2 * n2) * (1 + 2 * n1**2 - 8 * n1 * n2 + 2 * n2**2)) / (16. * n1 * (1 + n1) * (-1 + 2 * n1) * n2 * (1 + n2) * (-1 + 2 * n2)),
    27: lambda n1, n2: ((-3 + 2 * n1 + 2 * n2) * (-1 + 2 * n1 + 2 * n2) * (1 + 2 * n1 + 2 * n2) * (3 + 2 * n1 + 2 * n2)) / (32. * n1 * (1 + n1) * n2 * (1 + n2)),
}
# fmt: on


def M22a(n1, n2):
    """Common part of the 22-loop matrices"""
    return exp(loggamma(1.5 - n1) + loggamma(1.5 - n2) + loggamma(-1.5 + n1 + n2)) / (
        8.0 * pi**1.5 * exp(loggamma(n1) + loggamma(3 - n1 - n2) + loggamma(n2))
    )


def MPC(l, pn):
    r"""matrix for spherical bessel transform from power spectrum to correlation function
    Notes:
    -----
    The explicit expression can be written as:

    .. math::
        \frac{1}{2\pi^2}\int_0^\infty t^2 t^{-2pn}j_l(t)\;dt

    Note here if you want full result, this expression should be multiplied by :math:`s^{-3+2pn}`
    """
    # return pi**-1.5 * 2.**(-2. * pn) * gamma(1.5 + l / 2. - pn) / gamma(l / 2. + pn)
    return (
        pi**-1.5
        * 2.0 ** (-2.0 * pn)
        * exp(loggamma(1.5 + l / 2.0 - pn) - loggamma(l / 2.0 + pn))
    )


# fmt: off
# Resummation bulk coefficients Q^{ll'}_{||N-j}(n, \alpha) of the IR-resummation matrices.
# Q(N-j)(l)(l')(n)(\alpha). see in Resum(object) method Ps(self, bird) for details.
Q000 = {
    0: lambda f: (-3 - 2 * f - f**2) / 6.,
    1: lambda f: 0,
    2: lambda f: (15 + 20 * f + 22 * f**2 + 12 * f**3 + 3 * f**4) / 120.,
    3: lambda f: 0,
    4: lambda f: (-35 - 70 * f - 119 * f**2 - 124 * f**3 - 81 * f**4 - 30 * f**5 - 5 * f**6) / 1680.,
    5: lambda f: 0,
    6: lambda f: (0.125 + (f * (2 + f)) / 6. + (3 * f**2 * (2 + f)**2) / 20. + (f**3 * (2 + f)**3) / 14. + (f**4 * (2 + f)**4) / 72.) / 48.,
    7: lambda f: 0,
    8: lambda f: (-0.0625 - (5 * f * (2 + f)) / 48. - (f**2 * (2 + f)**2) / 8. - (5 * f**3 * (2 + f)**3) / 56. - (5 * f**4 * (2 + f)**4) / 144. - (f**5 * (2 + f)**5) / 176.) / 240.,
    9: lambda f: 0,
    10: lambda f: (0.03125 + (f * (2 + f)) / 16. + (3 * f**2 * (2 + f)**2) / 32. + (5 * f**3 * (2 + f)**3) / 56. + (5 * f**4 * (2 + f)**4) / 96. + (3 * f**5 * (2 + f)**5) / 176.) / 1440.,
    11: lambda f: 0,
    12: lambda f: (-495 - 1155 * f * (2 + f) - 2079 * f**2 * (2 + f)**2 - 2475 * f**3 * (2 + f)**3 - 1925 * f**4 * (2 + f)**4 - 945 * f**5 * (2 + f)**5) / 3.193344e8,
    13: lambda f: 0,
    14: lambda f: (0.0078125 + (f * (2 + f)) / 48. + (7 * f**2 * (2 + f)**2) / 160. + (f**3 * (2 + f)**3) / 16. + (35 * f**4 * (2 + f)**4) / 576. + (7 * f**5 * (2 + f)**5) / 176.) / 80640.,
    15: lambda f: 0,
    16: lambda f: (-3 - 2 * f - f**2) / 18.,
    17: lambda f: (15 + 10 * f + 2 * f**2) / 45.,
    18: lambda f: (15 + 20 * f + 22 * f**2 + 12 * f**3 + 3 * f**4) / 180.,
    19: lambda f: (-105 - 140 * f - 133 * f**2 - 66 * f**3 - 12 * f**4) / 630.,
    20: lambda f: (-35 - 70 * f - 119 * f**2 - 124 * f**3 - 81 * f**4 - 30 * f**5 - 5 * f**6) / 1680.,
    21: lambda f: (105 + 210 * f + 336 * f**2 + 336 * f**3 + 205 * f**4 + 70 * f**5 + 10 * f**6) / 2520.,
    22: lambda f: (315 + 840 * f + 1932 * f**2 + 2952 * f**3 + 3098 * f**4 + 2200 * f**5 + 1020 * f**6 + 280 * f**7 + 35 * f**8) / 90720.,
    23: lambda f: (-3465 - 9240 * f - 20559 * f**2 - 30690 * f**3 - 31207 * f**4 - 21380 * f**5 - 9465 * f**6 - 2450 * f**7 - 280 * f**8) / 498960.,
    24: lambda f: (-693 - 2310 * f - 6699 * f**2 - 13464 * f**3 - 19426 * f**4 - 20276 * f**5 - 15270 * f**6 - 8120 * f**7 - 2905 * f**8 - 630 * f**9 - 63 * f**10) / 1.596672e6,
    25: lambda f: (45045 + 150150 * f + 426426 * f**2 + 844272 * f**3 + 1195766 * f**4 + 1222780 * f**5 + 899040 * f**6 + 464800 * f**7 + 160685 * f**8 + 33390 * f**9 + 3150 * f**10) / 5.189184e7,
    26: lambda f: (3003 + 12012 * f + 42042 * f**2 + 104676 * f**3 + 192049 * f**4 + 264056 * f**5 + 274524 * f**6 + 215432 * f**7 + 125965 * f**8 + 53340 * f**9 + 15498 * f**10 + 2772 * f**11 + 231 * f**12) / 6.918912e7,
    27: lambda f: (-15015 - 60060 * f - 207207 * f**2 - 510510 * f**3 - 925210 * f**4 - 1255280 * f**5 - 1285670 * f**6 - 992068 * f**7 - 568995 * f**8 - 235620 * f**9 - 66675 * f**10 - 11550 * f**11 - 924 * f**12) / 1.729728e8,
    28: lambda f: (-6435 - 30030 * f - 123123 * f**2 - 365508 * f**3 - 813527 * f**4 - 1386970 * f**5 - 1805655 * f**6 - 1753240 * f**7 - 1229225 * f**8 - 598050 * f**9 - 190485 * f**10 - 35640 * f**11 - 2970 * f**12) / 1.7791488e9,
    29: lambda f: (45045 + 210210 * f + 852852 * f**2 + 2512224 * f**3 + 5542823 * f**4 + 9361690 * f**5 + 12053010 * f**6 + 11522224 * f**7 + 7904435 * f**8 + 3740310 * f**9 + 1152900 * f**10 + 207900 * f**11 + 16632 * f**12) / 6.2270208e9,
    30: lambda f: (6435 + 34320 * f + 161304 * f**2 + 555984 * f**3 + 1454596 * f**4 + 2958800 * f**5 + 4538760 * f**6 + 5017040 * f**7 + 3855250 * f**8 + 1990800 * f**9 + 656460 * f**10 + 124740 * f**11 + 10395 * f**12) / 2.49080832e10,
    31: lambda f: (-6435 - 34320 * f - 160017 * f**2 - 548262 * f**3 - 1424995 * f**4 - 2878460 * f**5 - 4374825 * f**6 - 4758362 * f**7 - 3568705 * f**8 - 1786680 * f**9 - 568575 * f**10 - 103950 * f**11 - 8316 * f**12) / 1.24540416e10,
}

Q002 = {
    0: lambda f: 0,
    1: lambda f: -(f * (2 + f)) / 15.,
    2: lambda f: 0,
    3: lambda f: (f * (14 + 19 * f + 12 * f**2 + 3 * f**3)) / 210.,
    4: lambda f: 0,
    5: lambda f: -(f * (42 + 93 * f + 112 * f**2 + 78 * f**3 + 30 * f**4 + 5 * f**5)) / 2520.,
    6: lambda f: 0,
    7: lambda f: (f * (462 + 1419 * f + 2508 * f**2 + 2837 * f**3 + 2110 * f**4 + 1005 * f**5 + 280 * f**6 + 35 * f**7)) / 166320.,
    8: lambda f: 0,
    9: lambda f: -(f * (6006 + 23595 * f + 54912 * f**2 + 85748 * f**3 + 94060 * f**4 + 73170 * f**5 + 39760 * f**6 + 14420 * f**7 + 3150 * f**8 + 315 * f**9)) / 1.729728e7,
    10: lambda f: 0,
    11: lambda f: (f * (6006 + 28743 * f + 82940 * f**2 + 165035 * f**3 + 238900 * f**4 + 242350 * f**5 + 162400 * f**6 + 67550 * f**7 + 15750 * f**8 + 1575 * f**9)) / 1.729728e8,
    12: lambda f: 0,
    13: lambda f: -(f * (6006 + 33891 * f + 116688 * f**2 + 282022 * f**3 + 506750 * f**4 + 607125 * f**5 + 450800 * f**6 + 198100 * f**7 + 47250 * f**8 + 4725 * f**9)) / 2.0756736e9,
    14: lambda f: 0,
    15: lambda f: (f * (858 + 5577 * f + 22308 * f**2 + 63427 * f**3 + 136070 * f**4 + 182745 * f**5 + 144200 * f**6 + 65275 * f**7 + 15750 * f**8 + 1575 * f**9)) / 4.1513472e9,
    16: lambda f: (f * (2 + f)) / 45.,
    17: lambda f: -(f * (28 + 11 * f)) / 315.,
    18: lambda f: -(f * (70 + 123 * f + 100 * f**2 + 28 * f**3)) / 4200.,
    19: lambda f: (f * (294 + 357 * f + 200 * f**2 + 44 * f**3)) / 2940.,
    20: lambda f: (f * (70 + 239 * f + 400 * f**2 + 349 * f**3 + 160 * f**4 + 30 * f**5)) / 25200.,
    21: lambda f: -(f * (686 + 1414 * f + 1580 * f**2 + 1017 * f**3 + 360 * f**4 + 55 * f**5)) / 17640.,
    22: lambda f: -(f * (2310 + 15411 * f + 42900 * f**2 + 65446 * f**3 + 60890 * f**4 + 34515 * f**5 + 11060 * f**6 + 1540 * f**7)) / 9.9792e6,
    23: lambda f: (f * (61446 + 179025 * f + 299640 * f**2 + 320318 * f**3 + 224650 * f**4 + 100665 * f**5 + 26320 * f**6 + 3080 * f**7)) / 6.98544e6,
    24: lambda f: (f**2 * (12012 + 57200 * f + 133757 * f**2 + 194470 * f**3 + 187375 * f**4 + 120820 * f**5 + 50435 * f**6 + 12390 * f**7 + 1365 * f**8)) / 8.64864e7,
    25: lambda f: -(f * (168168 + 633633 * f + 1412840 * f**2 + 2111122 * f**3 + 2213020 * f**4 + 1642840 * f**5 + 850640 * f**6 + 293510 * f**7 + 60900 * f**8 + 5775 * f**9)) / 1.2108096e8,
    26: lambda f: -(f * (-6006 + 7293 * f + 128700 * f**2 + 466336 * f**3 + 974660 * f**4 + 1365294 * f**5 + 1346744 * f**6 + 945700 * f**7 + 465570 * f**8 + 153405 * f**9 + 30492 * f**10 + 2772 * f**11)) / 2.0756736e9,
    27: lambda f: (f * (1219218 + 5636631 * f + 15701400 * f**2 + 30135040 * f**3 + 42038900 * f**4 + 43564362 * f**5 + 33692624 * f**6 + 19258540 * f**7 + 7922250 * f**8 + 2224215 * f**9 + 382536 * f**10 + 30492 * f**11)) / 7.2648576e9,
    28: lambda f: (f * (-30030 - 61347 * f + 171600 * f**2 + 1327183 * f**3 + 4003700 * f**4 + 7909560 * f**5 + 10765160 * f**6 + 9846550 * f**7 + 5868450 * f**8 + 2178225 * f**9 + 457380 * f**10 + 41580 * f**11)) / 6.2270208e10,
    29: lambda f: -(f * (714714 + 3915912 * f + 13084500 * f**2 + 30671459 * f**3 + 53418700 * f**4 + 69497811 * f**5 + 66220672 * f**6 + 44968070 * f**7 + 21026250 * f**8 + 6412770 * f**9 + 1147608 * f**10 + 91476 * f**11)) / 4.35891456e10,
    30: lambda f: -(f * (-4290 - 15873 * f - 14300 * f**2 + 97682 * f**3 + 503230 * f**4 + 1471985 * f**5 + 2619820 * f**6 + 2811200 * f**7 + 1832250 * f**8 + 712425 * f**9 + 152460 * f**10 + 13860 * f**11)) / 8.3026944e10,
    31: lambda f: (f * (78078 + 494637 * f + 1927640 * f**2 + 5337306 * f**3 + 11145230 * f**4 + 17062027 * f**5 + 18390624 * f**6 + 13588540 * f**7 + 6704250 * f**8 + 2108715 * f**9 + 382536 * f**10 + 30492 * f**11)) / 5.81188608e10,
}

Q020 = {
    0: lambda f: -(f * (2 + f)) / 3.,
    1: lambda f: 0,
    2: lambda f: (f * (14 + 19 * f + 12 * f**2 + 3 * f**3)) / 42.,
    3: lambda f: 0,
    4: lambda f: -(f * (42 + 93 * f + 112 * f**2 + 78 * f**3 + 30 * f**4 + 5 * f**5)) / 504.,
    5: lambda f: 0,
    6: lambda f: (f * (462 + 1419 * f + 2508 * f**2 + 2837 * f**3 + 2110 * f**4 + 1005 * f**5 + 280 * f**6 + 35 * f**7)) / 33264.,
    7: lambda f: 0,
    8: lambda f: -(f * (6006 + 23595 * f + 54912 * f**2 + 85748 * f**3 + 94060 * f**4 + 73170 * f**5 + 39760 * f**6 + 14420 * f**7 + 3150 * f**8 + 315 * f**9)) / 3.459456e6,
    9: lambda f: 0,
    10: lambda f: (f * (6006 + 28743 * f + 82940 * f**2 + 165035 * f**3 + 238900 * f**4 + 242350 * f**5 + 162400 * f**6 + 67550 * f**7 + 15750 * f**8 + 1575 * f**9)) / 3.459456e7,
    11: lambda f: 0,
    12: lambda f: -(f * (6006 + 33891 * f + 116688 * f**2 + 282022 * f**3 + 506750 * f**4 + 607125 * f**5 + 450800 * f**6 + 198100 * f**7 + 47250 * f**8 + 4725 * f**9)) / 4.1513472e8,
    13: lambda f: 0,
    14: lambda f: (f * (858 + 5577 * f + 22308 * f**2 + 63427 * f**3 + 136070 * f**4 + 182745 * f**5 + 144200 * f**6 + 65275 * f**7 + 15750 * f**8 + 1575 * f**9)) / 8.3026944e8,
    15: lambda f: 0,
    16: lambda f: -(f * (2 + f)) / 9.,
    17: lambda f: (f * (28 + 11 * f)) / 63.,
    18: lambda f: (f * (14 + 19 * f + 12 * f**2 + 3 * f**3)) / 63.,
    19: lambda f: -(f * (56 + 73 * f + 42 * f**2 + 9 * f**3)) / 126.,
    20: lambda f: -(f * (42 + 93 * f + 112 * f**2 + 78 * f**3 + 30 * f**4 + 5 * f**5)) / 504.,
    21: lambda f: (f * (924 + 2013 * f + 2332 * f**2 + 1550 * f**3 + 560 * f**4 + 85 * f**5)) / 5544.,
    22: lambda f: (f * (462 + 1419 * f + 2508 * f**2 + 2837 * f**3 + 2110 * f**4 + 1005 * f**5 + 280 * f**6 + 35 * f**7)) / 24948.,
    23: lambda f: -(f * (48048 + 146289 * f + 253110 * f**2 + 279487 * f**3 + 201860 * f**4 + 92775 * f**5 + 24710 * f**6 + 2905 * f**7)) / 1.297296e6,
    24: lambda f: (-5 * f * (6006 + 23595 * f + 54912 * f**2 + 85748 * f**3 + 94060 * f**4 + 73170 * f**5 + 39760 * f**6 + 14420 * f**7 + 3150 * f**8 + 315 * f**9)) / 1.0378368e7,
    25: lambda f: (f * (60060 + 234663 * f + 538824 * f**2 + 828932 * f**3 + 893680 * f**4 + 681498 * f**5 + 361816 * f**6 + 127652 * f**7 + 26964 * f**8 + 2583 * f**9)) / 1.0378368e7,
    26: lambda f: (f * (6006 + 28743 * f + 82940 * f**2 + 165035 * f**3 + 238900 * f**4 + 257134 * f**5 + 206752 * f**6 + 122990 * f**7 + 52710 * f**8 + 15435 * f**9 + 2772 * f**10 + 231 * f**11)) / 1.729728e7,
    27: lambda f: -(f * (408408 + 1947231 * f + 5566990 * f**2 + 10964915 * f**3 + 15691000 * f**4 + 16673022 * f**5 + 13213844 * f**6 + 7732830 * f**7 + 3252480 * f**8 + 931875 * f**9 + 163086 * f**10 + 13167 * f**11)) / 5.8810752e8,
    28: lambda f: -(f * (6006 + 33891 * f + 116688 * f**2 + 282022 * f**3 + 506750 * f**4 + 683157 * f**5 + 678896 * f**6 + 483220 * f**7 + 237330 * f**8 + 76005 * f**9 + 14256 * f**10 + 1188 * f**11)) / 1.7791488e8,
    29: lambda f: (f * (1429428 + 8044179 * f + 27509196 * f**2 + 65995462 * f**3 + 117612800 * f**4 + 157030581 * f**5 + 153987512 * f**6 + 107627380 * f**7 + 51668820 * f**8 + 16115085 * f**9 + 2935548 * f**10 + 237006 * f**11)) / 2.117187072e10,
    30: lambda f: (f * (3432 + 22308 * f + 89232 * f**2 + 253708 * f**3 + 544280 * f**4 + 864036 * f**5 + 975968 * f**6 + 760060 * f**7 + 395640 * f**8 + 131040 * f**9 + 24948 * f**10 + 2079 * f**11)) / 1.24540416e9,
    31: lambda f: -(f * (1633632 + 10596729 * f + 42168126 * f**2 + 119219555 * f**3 + 254186380 * f**4 + 400287321 * f**5 + 446018482 * f**6 + 340447835 * f**7 + 172819080 * f**8 + 55634355 * f**9 + 10274418 * f**10 + 829521 * f**11)) / 2.9640619008e11,
}

Q022 = {
    0: lambda f: 0,
    1: lambda f: (-21 - 22 * f - 11 * f**2) / 42.,
    2: lambda f: 0,
    3: lambda f: (21 + 44 * f + 58 * f**2 + 36 * f**3 + 9 * f**4) / 168.,
    4: lambda f: 0,
    5: lambda f: (-231 - 726 * f - 1551 * f**2 - 1868 * f**3 - 1317 * f**4 - 510 * f**5 - 85 * f**6) / 11088.,
    6: lambda f: 0,
    7: lambda f: (9009 + 37752 * f + 111540 * f**2 + 198744 * f**3 + 228766 * f**4 + 172520 * f**5 + 82980 * f**6 + 23240 * f**7 + 2905 * f**8) / 3.459456e6,
    8: lambda f: 0,
    9: lambda f: (-9009 - 47190 * f - 178035 * f**2 - 419640 * f**3 - 668810 * f**4 - 746356 * f**5 - 588390 * f**6 - 322840 * f**7 - 117845 * f**8 - 25830 * f**9 - 2583 * f**10) / 3.459456e7,
    10: lambda f: 0,
    11: lambda f: (3003 + 18876 * f + 86658 * f**2 + 254020 * f**3 + 516905 * f**4 + 762712 * f**5 + 783980 * f**6 + 529480 * f**7 + 221165 * f**8 + 51660 * f**9 + 5166 * f**10) / 1.3837824e8,
    12: lambda f: 0,
    13: lambda f: (-1287 - 9438 * f - 51051 * f**2 - 178932 * f**3 - 442883 * f**4 - 812218 * f**5 - 985095 * f**6 - 736120 * f**7 - 324485 * f**8 - 77490 * f**9 - 7749 * f**10) / 8.3026944e8,
    14: lambda f: 0,
    15: lambda f: (9009 + 75504 * f + 470184 * f**2 + 1917552 * f**3 + 5589388 * f**4 + 12249776 * f**5 + 16637880 * f**6 + 13198640 * f**7 + 5989270 * f**8 + 1446480 * f**9 + 144648 * f**10) / 9.299017728e10,
    16: lambda f: -0.041666666666666664 + (29 * f) / 630. + (2 * f**2) / 45.,
    17: lambda f: (-735 - 616 * f - 242 * f**2) / 1764.,
    18: lambda f: (35 - 2 * f - 91 * f**2 - 100 * f**3 - 32 * f**4) / 1680.,
    19: lambda f: (245 + 462 * f + 545 * f**2 + 300 * f**3 + 66 * f**4) / 1176.,
    20: lambda f: (-1155 - 1144 * f + 2794 * f**2 + 8380 * f**3 + 8897 * f**4 + 4460 * f**5 + 880 * f**6) / 221760.,
    21: lambda f: (-8085 - 23716 * f - 47168 * f**2 - 52700 * f**3 - 34341 * f**4 - 12240 * f**5 - 1870 * f**6) / 155232.,
    22: lambda f: (45045 + 91806 * f - 23595 * f**2 - 461760 * f**3 - 952577 * f**4 - 1006450 * f**5 - 611385 * f**6 - 203980 * f**7 - 29120 * f**8) / 5.189184e7,
    23: lambda f: (315315 + 1255254 * f + 3518229 * f**2 + 5935800 * f**3 + 6456811 * f**4 + 4591670 * f**5 + 2077815 * f**6 + 546140 * f**7 + 63910 * f**8) / 3.6324288e7,
    24: lambda f: (-15015 - 46332 * f - 46332 * f**2 + 133640 * f**3 + 553582 * f**4 + 966800 * f**5 + 1020100 * f**6 + 693560 * f**7 + 299425 * f**8 + 75180 * f**9 + 8400 * f**10) / 1.3837824e8,
    25: lambda f: (-105105 - 528528 * f - 1912482 * f**2 - 4318600 * f**3 - 6586006 * f**4 - 7023496 * f**5 - 5283944 * f**6 - 2762648 * f**7 - 959441 * f**8 - 199752 * f**9 - 18942 * f**10) / 9.6864768e7,
    26: lambda f: (765765 + 3165162 * f + 6439719 * f**2 - 198900 * f**3 - 34711790 * f**4 - 97981540 * f**5 - 155370642 * f**6 - 163957024 * f**7 - 120056615 * f**8 - 60772950 * f**9 - 20411685 * f**10 - 4110876 * f**11 - 376992 * f**12) / 7.05729024e10,
    27: lambda f: (5360355 + 32570538 * f + 144452451 * f**2 + 408739500 * f**3 + 802234420 * f**4 + 1140739100 * f**5 + 1200311862 * f**6 + 939355424 * f**7 + 541754395 * f**8 + 224309610 * f**9 + 63248535 * f**10 + 10902276 * f**11 + 869022 * f**12) / 4.940103168e10,
    28: lambda f: (-765765 - 3967392 * f - 11829246 * f**2 - 14254500 * f**3 + 24376793 * f**4 + 146125540 * f**5 + 350966652 * f**6 + 522521944 * f**7 + 501180365 * f**8 + 307125000 * f**9 + 116044110 * f**10 + 24665256 * f**11 + 2261952 * f**12) / 8.468748288e11,
    29: lambda f: (-5360355 - 38186148 * f - 200557500 * f**2 - 682160700 * f**3 - 1637570509 * f**4 - 2910901160 * f**5 - 3847513962 * f**6 - 3708394424 * f**7 - 2538283405 * f**8 - 1193047380 * f**9 - 365000580 * f**10 - 65413656 * f**11 - 5214132 * f**12) / 5.9281238016e11,
    30: lambda f: (255255 + 1589874 * f + 6177171 * f**2 + 12932920 * f**3 + 5992483 * f**4 - 51421090 * f**5 - 221113249 * f**6 - 443730868 * f**7 - 501406955 * f**8 - 335946450 * f**9 - 132885795 * f**10 - 28776132 * f**11 - 2638944 * f**12) / 3.9520825344e12,
    31: lambda f: (1786785 + 14600586 * f + 88617243 * f**2 + 352097200 * f**3 + 999436851 * f**4 + 2132033750 * f**5 + 3315874919 * f**6 + 3612890148 * f**7 + 2688572425 * f**8 + 1332462390 * f**9 + 420198765 * f**10 + 76315932 * f**11 + 6083154 * f**12) / 2.76645777408e12,
}

Q100 = {
    0: lambda f: 0,
    1: lambda f: 0,
    2: lambda f: (-15 - 20 * f - 22 * f**2 - 12 * f**3 - 3 * f**4) / 120.,
    3: lambda f: 0,
    4: lambda f: (35 + 70 * f + 119 * f**2 + 124 * f**3 + 81 * f**4 + 30 * f**5 + 5 * f**6) / 840.,
    5: lambda f: 0,
    6: lambda f: (-315 - 840 * f - 1932 * f**2 - 2952 * f**3 - 3098 * f**4 - 2200 * f**5 - 1020 * f**6 - 280 * f**7 - 35 * f**8) / 40320.,
    7: lambda f: 0,
    8: lambda f: (693 + 2310 * f + 6699 * f**2 + 13464 * f**3 + 19426 * f**4 + 20276 * f**5 + 15270 * f**6 + 8120 * f**7 + 2905 * f**8 + 630 * f**9 + 63 * f**10) / 665280.,
    9: lambda f: 0,
    10: lambda f: (-15015 - 60060 * f - 210210 * f**2 - 523380 * f**3 - 960245 * f**4 - 1320280 * f**5 - 1387404 * f**6 - 1121512 * f**7 - 685265 * f**8 - 303660 * f**9 - 91350 * f**10 - 16632 * f**11 - 1386 * f**12) / 1.3837824e8,
    11: lambda f: 0,
    12: lambda f: (6435 + 30030 * f + 123123 * f**2 + 365508 * f**3 + 813527 * f**4 + 1386970 * f**5 + 1837335 * f**6 + 1848280 * f**7 + 1348025 * f**8 + 677250 * f**9 + 220185 * f**10 + 41580 * f**11 + 3465 * f**12) / 6.918912e8,
    13: lambda f: 0,
    14: lambda f: (-6435 - 34320 * f - 161304 * f**2 - 555984 * f**3 - 1454596 * f**4 - 2958800 * f**5 - 4633800 * f**6 - 5302160 * f**7 - 4211650 * f**8 - 2228400 * f**9 - 745560 * f**10 - 142560 * f**11 - 11880 * f**12) / 9.4887936e9,
    15: lambda f: 0,
    16: lambda f: 0,
    17: lambda f: 0,
    18: lambda f: (-15 - 20 * f - 22 * f**2 - 12 * f**3 - 3 * f**4) / 180.,
    19: lambda f: (105 + 140 * f + 133 * f**2 + 66 * f**3 + 12 * f**4) / 630.,
    20: lambda f: (35 + 70 * f + 119 * f**2 + 124 * f**3 + 81 * f**4 + 30 * f**5 + 5 * f**6) / 840.,
    21: lambda f: (-105 - 210 * f - 336 * f**2 - 336 * f**3 - 205 * f**4 - 70 * f**5 - 10 * f**6) / 1260.,
    22: lambda f: (-315 - 840 * f - 1932 * f**2 - 2952 * f**3 - 3098 * f**4 - 2200 * f**5 - 1020 * f**6 - 280 * f**7 - 35 * f**8) / 30240.,
    23: lambda f: (3465 + 9240 * f + 20559 * f**2 + 30690 * f**3 + 31207 * f**4 + 21380 * f**5 + 9465 * f**6 + 2450 * f**7 + 280 * f**8) / 166320.,
    24: lambda f: (693 + 2310 * f + 6699 * f**2 + 13464 * f**3 + 19426 * f**4 + 20276 * f**5 + 15270 * f**6 + 8120 * f**7 + 2905 * f**8 + 630 * f**9 + 63 * f**10) / 399168.,
    25: lambda f: (-45045 - 150150 * f - 426426 * f**2 - 844272 * f**3 - 1195766 * f**4 - 1222780 * f**5 - 899040 * f**6 - 464800 * f**7 - 160685 * f**8 - 33390 * f**9 - 3150 * f**10) / 1.297296e7,
    26: lambda f: (-3003 - 12012 * f - 42042 * f**2 - 104676 * f**3 - 192049 * f**4 - 264056 * f**5 - 274524 * f**6 - 215432 * f**7 - 125965 * f**8 - 53340 * f**9 - 15498 * f**10 - 2772 * f**11 - 231 * f**12) / 1.3837824e7,
    27: lambda f: (15015 + 60060 * f + 207207 * f**2 + 510510 * f**3 + 925210 * f**4 + 1255280 * f**5 + 1285670 * f**6 + 992068 * f**7 + 568995 * f**8 + 235620 * f**9 + 66675 * f**10 + 11550 * f**11 + 924 * f**12) / 3.459456e7,
    28: lambda f: (6435 + 30030 * f + 123123 * f**2 + 365508 * f**3 + 813527 * f**4 + 1386970 * f**5 + 1837335 * f**6 + 1903192 * f**7 + 1540217 * f**8 + 965538 * f**9 + 460425 * f**10 + 161700 * f**11 + 39501 * f**12 + 6006 * f**13 + 429 * f**14) / 2.965248e8,
    29: lambda f: (-765765 - 3573570 * f - 14498484 * f**2 - 42707808 * f**3 - 94227991 * f**4 - 159148730 * f**5 - 208671090 * f**6 - 213722096 * f**7 - 170806867 * f**8 - 105586614 * f**9 - 49560000 * f**10 - 17094000 * f**11 - 4089393 * f**12 - 606606 * f**13 - 42042 * f**14) / 1.76432256e10,
    30: lambda f: (-6435 - 34320 * f - 161304 * f**2 - 555984 * f**3 - 1454596 * f**4 - 2958800 * f**5 - 4728840 * f**6 - 5916752 * f**7 - 5721202 * f**8 - 4195728 * f**9 - 2276100 * f**10 - 881100 * f**11 - 229581 * f**12 - 36036 * f**13 - 2574 * f**14) / 3.5582976e9,
    31: lambda f: (109395 + 583440 * f + 2720289 * f**2 + 9320454 * f**3 + 24224915 * f**4 + 48933820 * f**5 + 77603385 * f**6 + 96187258 * f**7 + 91894961 * f**8 + 66374712 * f**9 + 35346375 * f**10 + 13389750 * f**11 + 3404214 * f**12 + 519948 * f**13 + 36036 * f**14) / 3.02455296e10,
}

Q102 = {
    0: lambda f: 0,
    1: lambda f: 0,
    2: lambda f: 0,
    3: lambda f: -(f * (14 + 19 * f + 12 * f**2 + 3 * f**3)) / 210.,
    4: lambda f: 0,
    5: lambda f: (f * (42 + 93 * f + 112 * f**2 + 78 * f**3 + 30 * f**4 + 5 * f**5)) / 1260.,
    6: lambda f: 0,
    7: lambda f: -(f * (462 + 1419 * f + 2508 * f**2 + 2837 * f**3 + 2110 * f**4 + 1005 * f**5 + 280 * f**6 + 35 * f**7)) / 55440.,
    8: lambda f: 0,
    9: lambda f: (f * (6006 + 23595 * f + 54912 * f**2 + 85748 * f**3 + 94060 * f**4 + 73170 * f**5 + 39760 * f**6 + 14420 * f**7 + 3150 * f**8 + 315 * f**9)) / 4.32432e6,
    10: lambda f: 0,
    11: lambda f: -(f * (30030 + 143715 * f + 414700 * f**2 + 825175 * f**3 + 1194500 * f**4 + 1300454 * f**5 + 1078112 * f**6 + 670390 * f**7 + 300510 * f**8 + 91035 * f**9 + 16632 * f**10 + 1386 * f**11)) / 1.729728e8,
    12: lambda f: 0,
    13: lambda f: (f * (6006 + 33891 * f + 116688 * f**2 + 282022 * f**3 + 506750 * f**4 + 695829 * f**5 + 716912 * f**6 + 530740 * f**7 + 269010 * f**8 + 87885 * f**9 + 16632 * f**10 + 1386 * f**11)) / 3.459456e8,
    14: lambda f: 0,
    15: lambda f: -(f * (858 + 5577 * f + 22308 * f**2 + 63427 * f**3 + 136070 * f**4 + 220761 * f**5 + 258248 * f**6 + 207835 * f**7 + 110790 * f**8 + 37215 * f**9 + 7128 * f**10 + 594 * f**11)) / 5.930496e8,
    16: lambda f: 0,
    17: lambda f: 0,
    18: lambda f: (f * (70 + 123 * f + 100 * f**2 + 28 * f**3)) / 4200.,
    19: lambda f: -(f * (294 + 357 * f + 200 * f**2 + 44 * f**3)) / 2940.,
    20: lambda f: -(f * (70 + 239 * f + 400 * f**2 + 349 * f**3 + 160 * f**4 + 30 * f**5)) / 12600.,
    21: lambda f: (f * (686 + 1414 * f + 1580 * f**2 + 1017 * f**3 + 360 * f**4 + 55 * f**5)) / 8820.,
    22: lambda f: (f * (2310 + 15411 * f + 42900 * f**2 + 65446 * f**3 + 60890 * f**4 + 34515 * f**5 + 11060 * f**6 + 1540 * f**7)) / 3.3264e6,
    23: lambda f: -(f * (61446 + 179025 * f + 299640 * f**2 + 320318 * f**3 + 224650 * f**4 + 100665 * f**5 + 26320 * f**6 + 3080 * f**7)) / 2.32848e6,
    24: lambda f: -(f**2 * (12012 + 57200 * f + 133757 * f**2 + 194470 * f**3 + 187375 * f**4 + 120820 * f**5 + 50435 * f**6 + 12390 * f**7 + 1365 * f**8)) / 2.16216e7,
    25: lambda f: (f * (168168 + 633633 * f + 1412840 * f**2 + 2111122 * f**3 + 2213020 * f**4 + 1642840 * f**5 + 850640 * f**6 + 293510 * f**7 + 60900 * f**8 + 5775 * f**9)) / 3.027024e7,
    26: lambda f: (f * (-6006 + 7293 * f + 128700 * f**2 + 466336 * f**3 + 974660 * f**4 + 1365294 * f**5 + 1346744 * f**6 + 945700 * f**7 + 465570 * f**8 + 153405 * f**9 + 30492 * f**10 + 2772 * f**11)) / 4.1513472e8,
    27: lambda f: -(f * (1219218 + 5636631 * f + 15701400 * f**2 + 30135040 * f**3 + 42038900 * f**4 + 43564362 * f**5 + 33692624 * f**6 + 19258540 * f**7 + 7922250 * f**8 + 2224215 * f**9 + 382536 * f**10 + 30492 * f**11)) / 1.45297152e9,
    28: lambda f: -(f * (-510510 - 1042899 * f + 2917200 * f**2 + 22562111 * f**3 + 68062900 * f**4 + 130692600 * f**5 + 177848104 * f**6 + 178239110 * f**7 + 133005474 * f**8 + 73375365 * f**9 + 29170680 * f**10 + 7927227 * f**11 + 1321320 * f**12 + 102102 * f**13)) / 1.76432256e11,
    29: lambda f: (f * (12150138 + 66570504 * f + 222436500 * f**2 + 521414803 * f**3 + 908117900 * f**4 + 1207852227 * f**5 + 1242589376 * f**6 + 991225270 * f**7 + 609077322 * f**8 + 283426710 * f**9 + 96769596 * f**10 + 22904343 * f**11 + 3363360 * f**12 + 231231 * f**13)) / 1.235025792e11,
    30: lambda f: (f * (-72930 - 269841 * f - 243100 * f**2 + 1660594 * f**3 + 8554910 * f**4 + 22869505 * f**5 + 41588588 * f**6 + 53989120 * f**7 + 50143578 * f**8 + 32880105 * f**9 + 14817660 * f**10 + 4361544 * f**11 + 755040 * f**12 + 58344 * f**13)) / 2.01636864e11,
    31: lambda f: -(f * (1327326 + 8408829 * f + 32769880 * f**2 + 90734202 * f**3 + 189468910 * f**4 + 305134139 * f**5 + 379405152 * f**6 + 360586940 * f**7 + 257761434 * f**8 + 135510795 * f**9 + 50651832 * f**10 + 12717936 * f**11 + 1921920 * f**12 + 132132 * f**13)) / 1.411458048e11,
}

Q120 = {
    0: lambda f: 0,
    1: lambda f: 0,
    2: lambda f: -(f * (14 + 19 * f + 12 * f**2 + 3 * f**3)) / 42.,
    3: lambda f: 0,
    4: lambda f: (f * (42 + 93 * f + 112 * f**2 + 78 * f**3 + 30 * f**4 + 5 * f**5)) / 252.,
    5: lambda f: 0,
    6: lambda f: -(f * (462 + 1419 * f + 2508 * f**2 + 2837 * f**3 + 2110 * f**4 + 1005 * f**5 + 280 * f**6 + 35 * f**7)) / 11088.,
    7: lambda f: 0,
    8: lambda f: (f * (6006 + 23595 * f + 54912 * f**2 + 85748 * f**3 + 94060 * f**4 + 73170 * f**5 + 39760 * f**6 + 14420 * f**7 + 3150 * f**8 + 315 * f**9)) / 864864.,
    9: lambda f: 0,
    10: lambda f: -(f * (30030 + 143715 * f + 414700 * f**2 + 825175 * f**3 + 1194500 * f**4 + 1300454 * f**5 + 1078112 * f**6 + 670390 * f**7 + 300510 * f**8 + 91035 * f**9 + 16632 * f**10 + 1386 * f**11)) / 3.459456e7,
    11: lambda f: 0,
    12: lambda f: (f * (6006 + 33891 * f + 116688 * f**2 + 282022 * f**3 + 506750 * f**4 + 695829 * f**5 + 716912 * f**6 + 530740 * f**7 + 269010 * f**8 + 87885 * f**9 + 16632 * f**10 + 1386 * f**11)) / 6.918912e7,
    13: lambda f: 0,
    14: lambda f: -(f * (858 + 5577 * f + 22308 * f**2 + 63427 * f**3 + 136070 * f**4 + 220761 * f**5 + 258248 * f**6 + 207835 * f**7 + 110790 * f**8 + 37215 * f**9 + 7128 * f**10 + 594 * f**11)) / 1.1860992e8,
    15: lambda f: 0,
    16: lambda f: 0,
    17: lambda f: 0,
    18: lambda f: -(f * (14 + 19 * f + 12 * f**2 + 3 * f**3)) / 63.,
    19: lambda f: (f * (56 + 73 * f + 42 * f**2 + 9 * f**3)) / 126.,
    20: lambda f: (f * (42 + 93 * f + 112 * f**2 + 78 * f**3 + 30 * f**4 + 5 * f**5)) / 252.,
    21: lambda f: -(f * (924 + 2013 * f + 2332 * f**2 + 1550 * f**3 + 560 * f**4 + 85 * f**5)) / 2772.,
    22: lambda f: -(f * (462 + 1419 * f + 2508 * f**2 + 2837 * f**3 + 2110 * f**4 + 1005 * f**5 + 280 * f**6 + 35 * f**7)) / 8316.,
    23: lambda f: (f * (48048 + 146289 * f + 253110 * f**2 + 279487 * f**3 + 201860 * f**4 + 92775 * f**5 + 24710 * f**6 + 2905 * f**7)) / 432432.,
    24: lambda f: (5 * f * (6006 + 23595 * f + 54912 * f**2 + 85748 * f**3 + 94060 * f**4 + 73170 * f**5 + 39760 * f**6 + 14420 * f**7 + 3150 * f**8 + 315 * f**9)) / 2.594592e6,
    25: lambda f: -(f * (60060 + 234663 * f + 538824 * f**2 + 828932 * f**3 + 893680 * f**4 + 681498 * f**5 + 361816 * f**6 + 127652 * f**7 + 26964 * f**8 + 2583 * f**9)) / 2.594592e6,
    26: lambda f: -(f * (6006 + 28743 * f + 82940 * f**2 + 165035 * f**3 + 238900 * f**4 + 257134 * f**5 + 206752 * f**6 + 122990 * f**7 + 52710 * f**8 + 15435 * f**9 + 2772 * f**10 + 231 * f**11)) / 3.459456e6,
    27: lambda f: (f * (408408 + 1947231 * f + 5566990 * f**2 + 10964915 * f**3 + 15691000 * f**4 + 16673022 * f**5 + 13213844 * f**6 + 7732830 * f**7 + 3252480 * f**8 + 931875 * f**9 + 163086 * f**10 + 13167 * f**11)) / 1.17621504e8,
    28: lambda f: (f * (102102 + 576147 * f + 1983696 * f**2 + 4794374 * f**3 + 8614750 * f**4 + 11829093 * f**5 + 12571888 * f**6 + 10367924 * f**7 + 6591186 * f**8 + 3175725 * f**9 + 1123584 * f**10 + 275814 * f**11 + 42042 * f**12 + 3003 * f**13)) / 5.0409216e8,
    29: lambda f: -(f * (27159132 + 152839401 * f + 522674724 * f**2 + 1253913778 * f**3 + 2234643200 * f**4 + 3040883823 * f**5 + 3199917224 * f**6 + 2610171676 * f**7 + 1639270332 * f**8 + 779126775 * f**9 + 271444404 * f**10 + 65470482 * f**11 + 9777768 * f**12 + 681681 * f**13)) / 6.704425728e10,
    30: lambda f: -(f * (58344 + 379236 * f + 1516944 * f**2 + 4313036 * f**3 + 9252760 * f**4 + 15334884 * f**5 + 19683424 * f**6 + 19380572 * f**7 + 14395608 * f**8 + 7878600 * f**9 + 3067812 * f**10 + 802197 * f**11 + 126126 * f**12 + 9009 * f**13)) / 3.02455296e9,
    31: lambda f: (f * (31039008 + 201337851 * f + 801194394 * f**2 + 2265171545 * f**3 + 4829541220 * f**4 + 7949275803 * f**5 + 10119278134 * f**6 + 9860017601 * f**7 + 7228939032 * f**8 + 3894693705 * f**9 + 1489227894 * f**10 + 381565107 * f**11 + 58666608 * f**12 + 4090086 * f**13)) / 8.0453108736e11,
}

Q122 = {
    0: lambda f: 0,
    1: lambda f: 0,
    2: lambda f: 0,
    3: lambda f: (-21 - 44 * f - 58 * f**2 - 36 * f**3 - 9 * f**4) / 168.,
    4: lambda f: 0,
    5: lambda f: (231 + 726 * f + 1551 * f**2 + 1868 * f**3 + 1317 * f**4 + 510 * f**5 + 85 * f**6) / 5544.,
    6: lambda f: 0,
    7: lambda f: (-9009 - 37752 * f - 111540 * f**2 - 198744 * f**3 - 228766 * f**4 - 172520 * f**5 - 82980 * f**6 - 23240 * f**7 - 2905 * f**8) / 1.153152e6,
    8: lambda f: 0,
    9: lambda f: (9009 + 47190 * f + 178035 * f**2 + 419640 * f**3 + 668810 * f**4 + 746356 * f**5 + 588390 * f**6 + 322840 * f**7 + 117845 * f**8 + 25830 * f**9 + 2583 * f**10) / 8.64864e6,
    10: lambda f: 0,
    11: lambda f: (-255255 - 1604460 * f - 7365930 * f**2 - 21591700 * f**3 - 43936925 * f**4 - 64830520 * f**5 - 71694428 * f**6 - 60174184 * f**7 - 37759505 * f**8 - 17031420 * f**9 - 5179230 * f**10 - 948024 * f**11 - 79002 * f**12) / 2.35243008e9,
    12: lambda f: 0,
    13: lambda f: (21879 + 160446 * f + 867867 * f**2 + 3041844 * f**3 + 7529011 * f**4 + 13807706 * f**5 + 19274679 * f**6 + 20098232 * f**7 + 14996485 * f**8 + 7637490 * f**9 + 2501793 * f**10 + 474012 * f**11 + 39501 * f**12) / 2.35243008e9,
    14: lambda f: 0,
    15: lambda f: (-153153 - 1283568 * f - 7993128 * f**2 - 32598384 * f**3 - 95019596 * f**4 - 208246192 * f**5 - 343517496 * f**6 - 406397488 * f**7 - 329343350 * f**8 - 176274000 * f**9 - 59340456 * f**10 - 11376288 * f**11 - 948024 * f**12) / 2.2583328768e11,
    16: lambda f: 0,
    17: lambda f: 0,
    18: lambda f: (-35 + 2 * f + 91 * f**2 + 100 * f**3 + 32 * f**4) / 1680.,
    19: lambda f: (-245 - 462 * f - 545 * f**2 - 300 * f**3 - 66 * f**4) / 1176.,
    20: lambda f: (1155 + 1144 * f - 2794 * f**2 - 8380 * f**3 - 8897 * f**4 - 4460 * f**5 - 880 * f**6) / 110880.,
    21: lambda f: (8085 + 23716 * f + 47168 * f**2 + 52700 * f**3 + 34341 * f**4 + 12240 * f**5 + 1870 * f**6) / 77616.,
    22: lambda f: (-45045 - 91806 * f + 23595 * f**2 + 461760 * f**3 + 952577 * f**4 + 1006450 * f**5 + 611385 * f**6 + 203980 * f**7 + 29120 * f**8) / 1.729728e7,
    23: lambda f: (-315315 - 1255254 * f - 3518229 * f**2 - 5935800 * f**3 - 6456811 * f**4 - 4591670 * f**5 - 2077815 * f**6 - 546140 * f**7 - 63910 * f**8) / 1.2108096e7,
    24: lambda f: (15015 + 46332 * f + 46332 * f**2 - 133640 * f**3 - 553582 * f**4 - 966800 * f**5 - 1020100 * f**6 - 693560 * f**7 - 299425 * f**8 - 75180 * f**9 - 8400 * f**10) / 3.459456e7,
    25: lambda f: (105105 + 528528 * f + 1912482 * f**2 + 4318600 * f**3 + 6586006 * f**4 + 7023496 * f**5 + 5283944 * f**6 + 2762648 * f**7 + 959441 * f**8 + 199752 * f**9 + 18942 * f**10) / 2.4216192e7,
    26: lambda f: (-765765 - 3165162 * f - 6439719 * f**2 + 198900 * f**3 + 34711790 * f**4 + 97981540 * f**5 + 155370642 * f**6 + 163957024 * f**7 + 120056615 * f**8 + 60772950 * f**9 + 20411685 * f**10 + 4110876 * f**11 + 376992 * f**12) / 1.411458048e10,
    27: lambda f: (-5360355 - 32570538 * f - 144452451 * f**2 - 408739500 * f**3 - 802234420 * f**4 - 1140739100 * f**5 - 1200311862 * f**6 - 939355424 * f**7 - 541754395 * f**8 - 224309610 * f**9 - 63248535 * f**10 - 10902276 * f**11 - 869022 * f**12) / 9.880206336e9,
    28: lambda f: (14549535 + 75380448 * f + 224755674 * f**2 + 270835500 * f**3 - 463159067 * f**4 - 2776385260 * f**5 - 6428200308 * f**6 - 9561820744 * f**7 - 10093994855 * f**8 - 7790921208 * f**9 - 4399379670 * f**10 - 1778322084 * f**11 - 489097917 * f**12 - 82222140 * f**13 - 6390384 * f**14) / 2.6817702912e12,
    29: lambda f: (101846745 + 725536812 * f + 3810592500 * f**2 + 12961053300 * f**3 + 31113839671 * f**4 + 55307122040 * f**5 + 74783927838 * f**6 + 77946126440 * f**7 + 62820985255 * f**8 + 38912019804 * f**9 + 18218238360 * f**10 + 6248042724 * f**11 + 1483245225 * f**12 + 218137920 * f**13 + 14996982 * f**14) / 1.87723920384e12,
    30: lambda f: (-4849845 - 30207606 * f - 117366249 * f**2 - 245725480 * f**3 - 113857177 * f**4 + 977000710 * f**5 + 3720819571 * f**6 + 7698694108 * f**7 + 10669867985 * f**8 + 10294074966 * f**9 + 6913913265 * f**10 + 3166110948 * f**11 + 942381594 * f**12 + 164444280 * f**13 + 12780768 * f**14) / 1.07270811648e13,
    31: lambda f: (-33948915 - 277411134 * f - 1683727617 * f**2 - 6689846800 * f**3 - 18989300169 * f**4 - 40508641250 * f**5 - 66363948581 * f**6 - 83618177580 * f**7 - 80270077195 * f**8 - 57805024578 * f**9 - 30550231215 * f**10 - 11460369228 * f**11 - 2883933360 * f**12 - 436275840 * f**13 - 29993964 * f**14) / 7.50895681536e12,
}

# Q(N-j)(l)(l')
Qa = {
    0: {
        0: {0: Q000, 2: Q002},
        2: {0: Q020, 2: Q022}
    },
    1: {
        0: {0: Q100, 2: Q102},
        2: {0: Q120, 2: Q122}
    },
}

# precomputed k/q-arrays, in [h/Mpc] and [Mpc/h]
# TODO: match the kbin to pybird dev
kbird = np.array([0.001, 0.005, 0.0075, 0.01, 0.0125, 0.015, 0.0175, 0.02, 0.025, 0.03, 0.035, 0.04, 0.045, 0.05, 0.055, 0.06, 0.065, 0.07, 0.075, 0.08, 0.085, 0.09, 0.095,
                  0.1, 0.105, 0.11, 0.115, 0.12, 0.125, 0.13, 0.135, 0.14, 0.145, 0.15, 0.155, 0.16, 0.17, 0.18, 0.19, 0.2, 0.21, 0.22, 0.23, 0.24, 0.25, 0.26, 0.27, 0.28, 0.29, 0.3])
# kbird = np.array([0.001, 0.005, 0.0075, 0.01, 0.0125, 0.015, 0.0175, 0.02])
# _ = np.arange(kbird[-1], 0.3 + 1e-3, 0.005 / 1)
# kbird = np.concatenate([kbird, _[1:]])
sbird = np.array([1.000e+00, 1.124e+00, 1.264e+00, 1.421e+00, 1.597e+00, 1.796e+00, 2.019e+00, 2.270e+00, 2.551e+00, 2.868e+00, 3.225e+00, 3.625e+00, 4.075e+00, 4.582e+00, 5.151e+00, 5.790e+00, 6.510e+00, 7.318e+00, 8.227e+00, 9.249e+00, 1.040e+01, 1.169e+01, 1.314e+01, 1.477e+01, 1.661e+01, 1.867e+01, 2.099e+01, 2.360e+01, 2.653e+01, 2.982e+01, 3.353e+01, 3.769e+01, 4.238e+01, 4.764e+01, 5.356e+01, 6.000e+01, 6.021e+01, 6.526e+01, 6.769e+01,
                  7.053e+01, 7.579e+01, 7.609e+01, 8.105e+01, 8.555e+01, 8.632e+01, 9.158e+01, 9.617e+01, 9.684e+01, 1.021e+02, 1.074e+02, 1.081e+02, 1.126e+02, 1.179e+02, 1.215e+02, 1.232e+02, 1.284e+02, 1.337e+02, 1.366e+02, 1.389e+02, 1.442e+02, 1.495e+02, 1.536e+02, 1.547e+02, 1.600e+02, 1.727e+02, 1.941e+02, 2.183e+02, 2.454e+02, 2.759e+02, 3.101e+02, 3.486e+02, 3.919e+02, 4.406e+02, 4.954e+02, 5.569e+02, 6.261e+02, 7.038e+02, 7.912e+02, 8.895e+02, 1.000e+03])
# fmt: on


class Common(object):
    """
    A class to share data among different objects

    Attributes
    ----------
    Nl : int
        The maximum multipole to calculate (default 2)
    """

    def __init__(
        self,
        Nl: int = 2,
        kmin: float = 0.001,
        kmax: float = 0.3,
        optiresum: bool = False,
        kmA: float = 0.7,
        krA: float = 0.25,
        ndA: float = 3e-4,
        kmB: float | None = None,
        krB: float | None = None,
        ndB: float | None = None,
    ):
        self.optiresum = optiresum
        # set kmB and ndB when computing cross power spectrum
        self.kmA = kmA
        self.krA = krA
        self.ndA = ndA
        kmB = kmA if kmB is None else kmB
        krB = krA if krB is None else krB
        ndB = ndA if ndB is None else ndB
        self.kmB = kmB
        self.krB = krB
        self.ndB = ndB
        self.Nl = Nl
        self.N11 = 3
        self.Nct = 6
        self.N22 = 28  # number of 22-loops
        self.N13 = 10  # number of 13-loops
        self.Nloop = 12  # number of bias-independent loops
        self.k = (
            kbird  # np.arange(0.001, 0.3, 0.001)#kbird #np.arange(kmin, kmax, 0.01)
        )
        self.Nk = self.k.shape[0]
        if self.optiresum is True:
            self.s = np.arange(70.0, 200.0, 2.5)
        else:
            self.s = sbird
        self.Ns = self.s.shape[0]
        self.kr = self.k[0.02 <= self.k]
        self.Nkr = self.kr.shape[0]
        self.Nklow = self.Nk - self.Nkr
        # for resummation
        if self.Nl == 3:  # or np.max(self.k) > 0.25:
            self.NIR = 16
        else:
            self.NIR = 8

        if self.NIR == 16:
            self.Na = 3
        elif self.NIR == 8:
            self.Na = 2

        self.Nn = self.NIR * self.Na * 2

        self.l11 = np.empty(shape=(self.Nl, self.N11))
        self.lct = np.empty(shape=(self.Nl, self.Nct))
        self.l22 = np.empty(shape=(self.Nl, self.N22))
        self.l13 = np.empty(shape=(self.Nl, self.N13))

        for i in range(self.Nl):
            l = 2 * i
            self.l11[i] = np.array([mu[0][l], mu[2][l], mu[4][l]])
            self.lct[i] = np.array(
                [mu[0][l], mu[2][l], mu[4][l], mu[2][l], mu[4][l], mu[6][l]]
            )
            self.l22[i] = np.array(
                [
                    6 * [mu[0][l]]
                    + 7 * [mu[2][l]]
                    + [mu[4][l], mu[2][l], mu[4][l], mu[2][l], mu[4][l], mu[2][l]]
                    + 3 * [mu[4][l]]
                    + [mu[6][l], mu[4][l], mu[6][l], mu[4][l], mu[6][l], mu[8][l]]
                ]
            )
            self.l13[i] = np.array(
                [2 * [mu[0][l]] + 4 * [mu[2][l]] + 3 * [mu[4][l]] + [mu[6][l]]]
            )

        if self.optiresum is True:
            self.sLow = 70.0
            self.sHigh = 190.0
            self.idlow = np.where(self.s > self.sLow)[0][0]
            self.idhigh = np.where(self.s > self.sHigh)[0][0]
            self.sbao = self.s[self.idlow : self.idhigh]
            self.snobao = np.concatenate([self.s[: self.idlow], self.s[self.idhigh :]])
            self.sr = self.sbao
        else:
            self.sr = self.s


common = Common()


class BirdHook(Protocol):
    """accept a Bird object, and then do postprocessing"""

    def setreducePslb(self, bird: Bird) -> None:
        """automatically invoked when Bird.setreducePslb is called"""
        pass

    def setreducePG(self, bird: Bird) -> None:
        """automatically invoked when Bird.setreducePG is called"""
        pass


class BirdSnapshot(BirdHook):
    """
    created by Bird.create_snapshot, do not use this class directly
    """

    def __init__(self, bird: Bird) -> None:
        self.k = bird.co.k.copy()
        self.ls = [2 * i for i in range(bird.co.Nl)]
        self.P11l = bird.P11l.copy()
        self.Ploopl = bird.Ploopl.copy()
        self.Pctl = bird.Pctl.copy()
        self.Pstl = bird.Pstl.copy()
        self.Picc = bird.Picc.copy()

    def setreducePslb(self, bird: Bird) -> None:
        self.fullPs = bird.reducePslb(
            b11AB=bird.b11AB,
            bloopAB=bird.bloopAB,
            bctAB=bird.bctAB,
            bstAB=bird.bstAB,
            P11l=self.P11l,
            Ploopl=self.Ploopl,
            Pctl=self.Pctl,
            Pstl=self.Pstl,
            Picc=self.Picc,
        )


class Bird(object):
    """
    Main class which contains the power spectrum and correlation function, given a cosmology and a set of EFT parameters.
    Bird: Biased tracers in redshift space

    Attributes
    ----------
    co : class, optional
        An object of type Common() used to share data
    f : float
        Growth rate (for redshift space distortion)
    DA : float, optional
        Angular distance (for AP effect)
    H : float, optional
        Hubble parameter (for AP effect)
    z : float, optional
        Redshift (for AP effect)
    rdrag : float, optional
        rdrag (for alperp and alpara) in absolute units
    h : float, optional
        hubble parameter (for alperp and alpara)
    kin : array
        k-array on which the input linear power spectrum is evaluated
    Pin : array
        Input linear power spectrum
    Plin : scipy.interpolate.interp1d
        Interpolated function of the linear power spectrum
    P11 : ndarray
        Linear power spectrum evaluated on co.k (the internal k-array on which PyBird evaluates the power spectrum)
    P22 : ndarray
        To store the power spectrum 22-loop terms
    P13 : ndarray
        To store the power spectrum 13-loop terms
    C11 : ndarray
        To store the correlation function multipole linear terms
    C22 : ndarray
        To store the correlation function multipole 22-loop terms
    C13 : ndarray
        To store the correlation function multipole 13-loop terms
    Cct : ndarray
        To store the correlation function multipole counter terms
    Ps : ndarray
        To store the power spectrum multipole full linear part and full loop part (the loop including the counterterms)
    Cf : ndarray
        To store the correlation function multipole full linear part and full loop part (the loop including the counterterms)
    fullPs : ndarray
        To store the full power spectrum multipole (linear + loop)
    b11 : ndarray
        EFT parameters for the linear terms per multipole
    b13 : ndarray
        EFT parameters for the 13-loop terms per multipole
    b22 : ndarray
        EFT parameters for the 22-loop terms per multipole
    bct : ndarray
        EFT parameters for the counter terms per multipole
    """

    def __init__(
        self,
        kin,
        Plin,
        f,
        DA=None,
        H=None,
        z=None,
        co=common,
        rdrag: float | None = None,
        h: float | None = None,
    ):
        self.co = co

        self.f: float = f  # fN(Omega_m, z)
        self.DA = DA
        self.H = H
        self.z = z
        self.rdrag = rdrag
        self.h = h

        self.kin = kin
        self.Pin = Plin
        self.Plin = interp1d(kin, Plin, kind="cubic")
        self.P11 = self.Plin(self.co.k)
        self.P22 = np.empty(shape=(self.co.N22, self.co.Nk))
        self.P13 = np.empty(shape=(self.co.N13, self.co.Nk))

        self.Ploopl = np.empty(shape=(self.co.Nl, self.co.Nloop, self.co.Nk))
        self.Cloopl = np.empty(shape=(self.co.Nl, self.co.Nloop, self.co.Ns))
        self.P11l = np.empty(shape=(self.co.Nl, self.co.N11, self.co.Nk))
        self.Pctl = np.empty(shape=(self.co.Nl, self.co.Nct, self.co.Nk))
        self.P22l = np.empty(shape=(self.co.Nl, self.co.N22, self.co.Nk))
        self.P13l = np.empty(shape=(self.co.Nl, self.co.N13, self.co.Nk))
        self.Pb3 = np.empty(shape=(self.co.Nl, self.co.Nk))
        # stochastic terms
        self.Pstl = np.empty(shape=(self.co.Nl, 3, self.co.Nk))

        self.C11 = np.empty(shape=(self.co.Nl, self.co.Ns))
        self.C22 = np.empty(shape=(self.co.Nl, self.co.N22, self.co.Ns))
        self.C13 = np.empty(shape=(self.co.Nl, self.co.N13, self.co.Ns))
        self.Cct = np.empty(shape=(self.co.Nl, self.co.Ns))
        self.b11 = np.empty(shape=(self.co.Nl))
        self.b13 = np.empty(shape=(self.co.Nl, self.co.N13))
        self.b22 = np.empty(shape=(self.co.Nl, self.co.N22))
        self.bct = np.empty(shape=(self.co.Nl))
        self.Ps = np.empty(shape=(2, self.co.Nl, self.co.Nk))
        self.Cf = np.empty(shape=(2, self.co.Nl, self.co.Ns))
        self.fullPs = np.empty(shape=(self.co.Nl, self.co.Nk))
        # integral constraint terms, "constant" part
        # observational effects **after** fiber collision will have effect on it, e.g. binning
        # The rationale is, pixelation is performed after fiber collision and affects typically large-scale modes
        self.Picc = np.zeros(shape=(self.co.Nl, self.co.Nk))

        self._hooks: list[BirdHook] = []
        self.snapshots: dict[str, BirdSnapshot] = {}

    def attach_hook(self, *args: BirdHook) -> None:
        self._hooks.extend(args)

    def clear_hook(self) -> None:
        self._hooks = []

    def create_snapshot(self, name: str) -> None:
        """
        Notes
        -----
        be careful with the name, because name confliction not checked
        """
        # XXX: name confliction not checked
        snapshot = BirdSnapshot(self)
        self.snapshots[name] = snapshot
        self.attach_hook(snapshot)

    def setPsCfl(self):
        """Creates multipoles for each term weighted accordingly"""
        self.P11l = np.einsum("x,ln->lnx", self.P11, self.co.l11)
        self.Pctl = np.einsum("x,x,ln->lnx", self.co.k**2, self.P11, self.co.lct)
        self.P22l = np.einsum("nx,ln->lnx", self.P22, self.co.l22)
        self.P13l = np.einsum("nx,ln->lnx", self.P13, self.co.l13)

        self.C22 = np.einsum("lnx,ln->lnx", self.C22, self.co.l22)
        self.C13 = np.einsum("lnx,ln->lnx", self.C13, self.co.l13)

        self.reducePsCfl()
        self.setPstl()

    def reducePsCfl(self):
        """Regroups terms that share the same EFT parameter(s)"""
        f1 = self.f

        self.Ploopl[:, 0] = (
            f1**2 * self.P22l[:, 20]
            + f1**3 * self.P22l[:, 23]
            + f1**3 * self.P22l[:, 24]
            + f1**4 * self.P22l[:, 25]
            + f1**4 * self.P22l[:, 26]
            + f1**4 * self.P22l[:, 27]
            + f1**2 * self.P13l[:, 7]
            + f1**3 * self.P13l[:, 8]
            + f1**3 * self.P13l[:, 9]
        )  # *1
        self.Ploopl[:, 1] = (
            f1 * self.P22l[:, 9]
            + f1**2 * self.P22l[:, 14]
            + f1**2 * self.P22l[:, 15]
            + f1**3 * self.P22l[:, 21]
            + f1**3 * self.P22l[:, 22]
            + f1 * self.P13l[:, 3]
            + f1**2 * self.P13l[:, 5]
            + f1**2 * self.P13l[:, 6]
        )  # *b1
        self.Ploopl[:, 2] = (
            f1 * self.P22l[:, 10]
            + f1**2 * self.P22l[:, 16]
            + f1**2 * self.P22l[:, 17]
        )  # *b2
        self.Ploopl[:, 3] = f1 * self.P13l[:, 4]  # *b3
        self.Ploopl[:, 4] = (
            f1 * self.P22l[:, 11]
            + f1**2 * self.P22l[:, 18]
            + f1**2 * self.P22l[:, 19]
        )  # *b4
        self.Ploopl[:, 5] = (
            self.P22l[:, 0]
            + f1 * self.P22l[:, 6]
            + f1**2 * self.P22l[:, 12]
            + f1**2 * self.P22l[:, 13]
            + self.P13l[:, 0]
            + f1 * self.P13l[:, 2]
        )  # *b1*b1
        self.Ploopl[:, 6] = self.P22l[:, 1] + f1 * self.P22l[:, 7]  # *b1*b2
        self.Ploopl[:, 7] = self.P13l[:, 1]  # *b1*b3
        self.Ploopl[:, 8] = self.P22l[:, 2] + f1 * self.P22l[:, 8]  # *b1*b4
        self.Ploopl[:, 9] = self.P22l[:, 3]  # *b2*b2
        self.Ploopl[:, 10] = self.P22l[:, 4]  # *b2*b4
        self.Ploopl[:, 11] = self.P22l[:, 5]  # *b4*b4

        self.Cloopl[:, 0] = (
            f1**2 * self.C22[:, 20]
            + f1**3 * self.C22[:, 23]
            + f1**3 * self.C22[:, 24]
            + f1**4 * self.C22[:, 25]
            + f1**4 * self.C22[:, 26]
            + f1**4 * self.C22[:, 27]
            + f1**2 * self.C13[:, 7]
            + f1**3 * self.C13[:, 8]
            + f1**3 * self.C13[:, 9]
        )  # *1
        self.Cloopl[:, 1] = (
            f1 * self.C22[:, 9]
            + f1**2 * self.C22[:, 14]
            + f1**2 * self.C22[:, 15]
            + f1**3 * self.C22[:, 21]
            + f1**3 * self.C22[:, 22]
            + f1 * self.C13[:, 3]
            + f1**2 * self.C13[:, 5]
            + f1**2 * self.C13[:, 6]
        )  # *b1
        self.Cloopl[:, 2] = (
            f1 * self.C22[:, 10] + f1**2 * self.C22[:, 16] + f1**2 * self.C22[:, 17]
        )  # *b2
        self.Cloopl[:, 3] = f1 * self.C13[:, 4]  # *b3
        self.Cloopl[:, 4] = (
            f1 * self.C22[:, 11] + f1**2 * self.C22[:, 18] + f1**2 * self.C22[:, 19]
        )  # *b4
        self.Cloopl[:, 5] = (
            self.C22[:, 0]
            + f1 * self.C22[:, 6]
            + f1**2 * self.C22[:, 12]
            + f1**2 * self.C22[:, 13]
            + self.C13[:, 0]
            + f1 * self.C13[:, 2]
        )  # *b1*b1
        self.Cloopl[:, 6] = self.C22[:, 1] + f1 * self.C22[:, 7]  # *b1*b2
        self.Cloopl[:, 7] = self.C13[:, 1]  # *b1*b3
        self.Cloopl[:, 8] = self.C22[:, 2] + f1 * self.C22[:, 8]  # *b1*b4
        self.Cloopl[:, 9] = self.C22[:, 3]  # *b2*b2
        self.Cloopl[:, 10] = self.C22[:, 4]  # *b2*b4
        self.Cloopl[:, 11] = self.C22[:, 5]  # *b4*b4

        self.subtractShotNoise()

    def setPstl(self, ks: NDArray | None = None):
        """stochastic terms"""
        if ks is None:
            Nk = self.co.Nk
            ks2 = self.co.k**2
        else:
            Nk = ks.shape[0]
            ks2 = ks**2
        Nl = self.co.Nl
        self.Pstl = np.zeros(shape=(Nl, 3, Nk), dtype=np.float64)
        self.Pstl[0, 0, :] = np.ones(shape=(Nk,), dtype=np.float64)
        self.Pstl[0, 1, :] = ks2
        if Nl >= 2:
            self.Pstl[1, 2, :] = ks2

    def setreducePslb(
        self,
        bsA: Iterable[float],
        bsB: Iterable[float] | None = None,
        es: Iterable[float] = (0.0, 0.0, 0.0),
    ) -> None:
        """apply counter terms and bind fullPs to self

        Parameters
        ----------
        bsA : Iterable[float]
            b_1, b_2, b_3, b_4, c_{ct}, c_{r,1}, c{r,2}
        bsB : Iterable[float], optional
            the same as bsA, but for tracer B, by default None,
            and will compute auto power spectrum
        es : Iterable[float], optional
            c_{e,0}, c_{mono}, c_{quad}, by default zeros
        """
        kmA, krA, ndA, kmB, krB, ndB = (
            self.co.kmA,
            self.co.krA,
            self.co.ndA,
            self.co.kmB,
            self.co.krB,
            self.co.ndB,
        )
        b1A, b2A, b3A, b4A, cctA, cr1A, cr2A = bsA
        if bsB is None:
            bsB = bsA
        b1B, b2B, b3B, b4B, cctB, cr1B, cr2B = bsB
        f = self.f
        ce0, cemono, cequad = es

        # cct -> cct / km**2, cr1 -> cr1 / kr**2, cr2 -> cr2 / kr**2
        # ce0 -> ce0 / nd, cemono -> cemono / nd / km**2, cequad -> cequad / nd / km**2
        b11AB = np.array([b1A * b1B, (b1A + b1B) * f, f**2])
        bctAB = np.array(
            [
                b1A * cctB / kmB**2 + b1B * cctA / kmA**2,
                b1B * cr1A / krA**2 + b1A * cr1B / krB**2,
                b1B * cr2A / krA**2 + b1A * cr2B / krB**2,
                (cctA / kmA**2 + cctB / kmB**2) * f,
                (cr1A / krA**2 + cr1B / krB**2) * f,
                (cr2A / krA**2 + cr2B / krB**2) * f,
            ]
        )
        bloopAB = np.array(
            [
                1.0,
                1.0 / 2.0 * (b1A + b1B),
                1.0 / 2.0 * (b2A + b2B),
                1.0 / 2.0 * (b3A + b3B),
                1.0 / 2.0 * (b4A + b4B),
                b1A * b1B,
                1.0 / 2.0 * (b1A * b2B + b1B * b2A),
                1.0 / 2.0 * (b1A * b3B + b1B * b3A),
                1.0 / 2.0 * (b1A * b4B + b1B * b4A),
                b2A * b2B,
                1.0 / 2.0 * (b2A * b4B + b2B * b4A),
                b4A * b4B,
            ]
        )
        xfactor1 = 0.5 * (1.0 / ndA + 1.0 / ndB)
        xfactor2 = 0.5 * (1.0 / ndA / kmA**2 + 1.0 / ndB / kmB**2)
        bstAB = np.array([ce0 * xfactor1, cemono * xfactor2, cequad * xfactor2])

        self.b11AB = b11AB
        self.bctAB = bctAB
        self.bloopAB = bloopAB
        self.bstAB = bstAB
        self.fullPs = self.reducePslb(
            b11AB=b11AB,
            bloopAB=bloopAB,
            bctAB=bctAB,
            bstAB=bstAB,
            P11l=self.P11l,
            Ploopl=self.Ploopl,
            Pctl=self.Pctl,
            Pstl=self.Pstl,
            Picc=self.Picc,
        )
        for viewer in self._hooks:
            viewer.setreducePslb(self)

    def reducePslb(
        self, *, b11AB, bloopAB, bctAB, bstAB, P11l, Ploopl, Pctl, Pstl, Picc
    ) -> NDArray:
        Ps0 = np.einsum("b,lbx->lx", b11AB, P11l)
        Ps1 = np.einsum("b,lbx->lx", bloopAB, Ploopl) + np.einsum(
            "b,lbx->lx", bctAB, Pctl
        )
        Ps2 = np.einsum("b,lbx->lx", bstAB, Pstl)
        # from matplotlib import pyplot as plt
        # k = self.co.k
        # plt.plot(k, k * Ps0[0], "k-", label="kaiser")
        # plt.plot(k, k * Ps0[1], "b-")
        # _Ploop = np.einsum("b,lbx->lx", bloopAB, Ploopl)
        # _Pct = np.einsum("b,lbx->lx", bctAB, Pctl)
        # plt.plot(k, k * _Ploop[0], "k--", label="loop")
        # plt.plot(k, k * _Ploop[1], "b--")
        # plt.plot(k, k * _Pct[0], "k:", label="counter")
        # plt.plot(k, k * _Pct[1], "b:")
        # plt.legend(frameon=False)
        # plt.xlim(0, 0.3)
        # plt.ylim(-300, 450)
        # plt.show()
        return Ps0 + Ps1 + Ps2 + Picc

    def subtractShotNoise(self):
        """Subtract the constant stochastic term from the (22-)loop"""
        for l in range(self.co.Nl):
            for n in range(self.co.Nloop):
                shotnoise = self.Ploopl[l, n, 0]
                self.Ploopl[l, n] -= shotnoise

    def setreducePG(self, b1A: float, b1B: float) -> None:

        self.b1A = b1A
        self.b1B = b1B

        self.PG = self.reducePG(
            b1A=b1A, b1B=b1B, Ploopl=self.Ploopl, Pctl=self.Pctl, Pstl=self.Pstl
        )

        for viewer in self._hooks:
            viewer.setreducePG(self)

    def reducePG(
        self, b1A: float, b1B: float, Ploopl: NDArray, Pctl: NDArray, Pstl: NDArray
    ) -> dict[str, NDArray]:
        f = self.f
        kmA, krA, ndA, kmB, krB, ndB = (
            self.co.kmA,
            self.co.krA,
            self.co.ndA,
            self.co.kmB,
            self.co.krB,
            self.co.ndB,
        )
        PG: dict[str, Any] = {}
        PG["b3A"] = 1 / 2 * Ploopl[:, 3, :] + 1 / 2 * b1B * Ploopl[:, 7, :]
        PG["cctA"] = b1B / kmA**2 * Pctl[:, 0, :] + f / kmA**2 * Pctl[:, 3, :]
        PG["cr1A"] = b1B / krA**2 * Pctl[:, 1, :] + f / krA**2 * Pctl[:, 4, :]
        PG["cr2A"] = b1B / krA**2 * Pctl[:, 2, :] + f / krA**2 * Pctl[:, 5, :]
        PG["b3B"] = 1 / 2 * Ploopl[:, 3, :] + 1 / 2 * b1A * Ploopl[:, 7, :]
        PG["cctB"] = b1A / kmB**2 * Pctl[:, 0, :] + f / kmB**2 * Pctl[:, 3, :]
        PG["cr1B"] = b1A / krB**2 * Pctl[:, 1, :] + f / krB**2 * Pctl[:, 4, :]
        PG["cr2B"] = b1A / krB**2 * Pctl[:, 2, :] + f / krB**2 * Pctl[:, 5, :]
        xfactor1 = 0.5 * (1.0 / ndA + 1.0 / ndB)
        xfactor2 = 0.5 * (1.0 / ndA / kmA**2 + 1.0 / ndB / kmB**2)
        PG["ce0"] = Pstl[:, 0, :] * xfactor1
        PG["cemono"] = Pstl[:, 1, :] * xfactor2
        PG["cequad"] = Pstl[:, 2, :] * xfactor2
        return PG


# TODO: support snapshot
class NonLinear(HasLogger):
    """
    given a Bird() object, computes the one-loop power spectrum and one-loop correlation function.
    The correlation function is useful to perform the IR-resummation of the power spectrum.
    The loop and spherical Bessel transform matrices are either loaded either precomputed and stored at the instanciation of the class.

    Attributes
    ----------
    co : class
        An object of type Common() used to share data
    fftsettings: dict
    fft : class
        An object of type FFTLog() to perform the FFTLog
    M22 : ndarray
        22-loop power spectrum matrices
    M13 : ndarray
        13-loop power spectrum matrices
    Mcf11 : ndarray
        Spherical Bessel transform matrices of the linear power spectrum to correlation function
    Ml : ndarray
        Spherical Bessel transform matrices of the loop power spectrum to correlation function multipole. Auxiliary matrices used for the loop correlation function matrices.
    Mcf22 : ndarray
        22-loop correlation function multipole matrices
    Mcf13 : ndarray
        13-loop correlation function multipole matrices
    kPow : ndarray
        k's to the powers on which to perform the FFTLog to evaluate the loop power spectrum
    sPow : ndarray
        s's to the powers on which to perform the FFTLog to evaluate the loop correlation function
    optipathP22 : NumPy einsum_path
        Optimization settings for NumPy einsum when performing matrix multiplications to compute the 22-loop power spectrum. For speedup purpose in repetitive evaluations.
    optipathC13 : NumPy einsum_path
        Optimization settings for NumPy einsum when performing matrix multiplications to compute the 13-loop correlation function. For speedup purpose in repetitive evaluations.
    optipathC22 : NumPy einsum_path
        Optimization settings for NumPy einsum when performing matrix multiplications to compute the 22-loop correlation function. For speedup purpose in repetitive evaluations.
    """

    def __init__(
        self,
        load=True,
        save=True,
        path="./",
        NFFT=256,
        co=common,
        name="pybird.nonlinear",
    ):
        self.set_logger(name=name)
        self.co = co

        self.fftsettings = dict(Nmax=NFFT, xmin=1.5e-5, xmax=1000.0, bias=-1.6)

        self.fft = FFTLog(**self.fftsettings)

        if load is True:
            try:
                L = np.load(os.path.join(path, f"pyegg{NFFT}_Nl{co.Nl}.npz"))
                if (self.fft.Pow - L["Pow"]).any():
                    self.mpi_warning(
                        "Loaded loop matrices do not correspond to asked FFTLog configuration, computing new matrices."
                    )
                    load = False
                else:
                    (
                        self.M22,
                        self.M13,
                        self.Mcf11,
                        self.Mcf22,
                        self.Mcf13,
                        self.Mcfct,
                    ) = (
                        L["M22"],
                        L["M13"],
                        L["Mcf11"],
                        L["Mcf22"],
                        L["Mcf13"],
                        L["Mcfct"],
                    )
                    save = False
            except:
                self.mpi_warning(
                    "Can't load loop matrices at %s, computing new matrices.", path
                )
                load = False

        if load is False:
            self.setM22()
            self.setM13()
            self.setMl()
            self.setMcf11()
            self.setMcf22()
            self.setMcf13()
            self.setMcfct()

        if save is True:
            try:
                if is_main_process():
                    np.savez(
                        os.path.join(path, f"pyegg{NFFT}_Nl{co.Nl}.npz"),
                        Pow=self.fft.Pow,
                        M22=self.M22,
                        M13=self.M13,
                        Mcf11=self.Mcf11,
                        Mcf22=self.Mcf22,
                        Mcf13=self.Mcf13,
                        Mcfct=self.Mcfct,
                    )
            except:
                self.mpi_warning("Can't save loop matrices at %s.", path)

        self.setkPow()
        self.setsPow()

        # To speed-up matrix multiplication:
        self.optipathP13 = np.einsum_path(
            "nk,bn->bk", self.kPow, self.M13, optimize="optimal"
        )[0]
        self.optipathP22 = np.einsum_path(
            "nk,mk,bnm->bk", self.kPow, self.kPow, self.M22, optimize="optimal"
        )[0]
        self.optipathC11 = np.einsum_path(
            "ns,ln->ls", self.sPow, self.Mcf11, optimize="optimal"
        )[0]
        self.optipathCct = np.einsum_path(
            "ns,ln->ls", self.sPow, self.Mcfct, optimize="optimal"
        )[0]
        self.optipathC13 = np.einsum_path(
            "ns,ms,blnm->bls", self.sPow, self.sPow, self.Mcf22, optimize="optimal"
        )[0]
        self.optipathC22 = np.einsum_path(
            "ns,ms,blnm->bls", self.sPow, self.sPow, self.Mcf13, optimize="optimal"
        )[0]

    def setM22(self):
        """Compute the 22-loop power spectrum matrices. Called at the instantiation of the class if the matrices are not loaded."""
        self.M22 = np.empty(
            shape=(self.co.N22, self.fft.Pow.shape[0], self.fft.Pow.shape[0]),
            dtype="complex",
        )
        ns = -0.5 * self.fft.Pow
        # common piece of M22
        Ma = M22a(ns[:, None], ns[None, :])
        for i in range(self.co.N22):
            # singular piece of M22
            self.M22[i] = Ma * M22b[i](ns[:, None], ns[None, :])

    def setM13(self):
        """Compute the 13-loop power spectrum matrices. Called at the instantiation of the class if the matrices are not loaded."""
        self.M13 = np.empty(shape=(self.co.N13, self.fft.Pow.shape[0]), dtype="complex")
        Ma = M13a(-0.5 * self.fft.Pow)
        for i in range(self.co.N13):
            self.M13[i] = Ma * M13b[i](-0.5 * self.fft.Pow)

    def setMcf11(self):
        """Compute the 11-loop correlation function matrices. Called at the instantiation of the class if the matrices are not loaded."""
        # self.Mcf11 = np.empty(shape=(self.co.Nl, self.fft.Pow.shape[0]), dtype='complex')
        ns = -0.5 * self.fft.Pow
        self.Mcf11 = MPC(2 * np.arange(self.co.Nl)[:, None], ns[None, :])  # * 1j**(2*l)

    def setMl(self):
        """Compute the power spectrum to correlation function spherical Bessel transform matrices. Called at the instantiation of the class if the matrices are not loaded."""
        # self.Ml = np.empty(shape=(self.co.Nl, self.fft.Pow.shape[0], self.fft.Pow.shape[0]), dtype='complex')
        ns = -0.5 * self.fft.Pow
        self.Ml = MPC(
            2 * np.arange(self.co.Nl)[:, None, None],
            ns[None, :, None] + ns[None, None, :] - 1.5,
        )  # * 1j**(2*l)

    def setMcf22(self):
        """Compute the 22-loop correlation function matrices. Called at the instantiation of the class if the matrices are not loaded."""
        self.Mcf22 = np.einsum("lnm,bnm->blnm", self.Ml, self.M22)

    def setMcf13(self):
        """Compute the 13-loop correlation function matrices. Called at the instantiation of the class if the matrices are not loaded."""
        self.Mcf13 = np.einsum("lnm,bn->blnm", self.Ml, self.M13)

    def setMcfct(self):
        """Compute the counterterm correlation function matrices. Called at the instantiation of the class if the matrices are not loaded."""
        # self.Mcfct = np.empty(shape=(self.co.Nl, self.fft.Pow.shape[0]), dtype='complex')
        ns = -0.5 * self.fft.Pow
        self.Mcfct = MPC(2 * np.arange(self.co.Nl)[:, None], ns - 1.0)  # * 1j**(2*l)

    def setkPow(self):
        """Compute the k's to the powers of the FFTLog to evaluate the loop power spectrum. Called at the instantiation of the class."""
        self.kPow = exp(np.einsum("n,k->nk", self.fft.Pow, log(self.co.k)))

    def setsPow(self):
        """Compute the s's to the powers of the FFTLog to evaluate the loop correlation function. Called at the instantiation of the class."""
        self.sPow = exp(np.einsum("n,s->ns", -self.fft.Pow - 3.0, log(self.co.s)))

    def CoefkPow(self, Coef):
        """Multiply the coefficients with the k's to the powers of the FFTLog to evaluate the loop power spectrum."""
        return Coef[:, newaxis] * self.kPow

    def CoefsPow(self, Coef):
        """Multiply the coefficients with the s's to the powers of the FFTLog to evaluate the correlation function."""
        return Coef[:, newaxis] * self.sPow

    def makeP22(self, CoefkPow, bird):
        """Perform the 22-loop power spectrum matrix multiplications"""
        bird.P22 = self.co.k**3 * np.real(
            np.einsum(
                "nk,mk,bnm->bk", CoefkPow, CoefkPow, self.M22, optimize=self.optipathP22
            )
        )

    def makeP13(self, CoefkPow, bird):
        """Perform the 13-loop power spectrum matrix multiplications"""
        bird.P13 = (
            self.co.k**3
            * bird.P11
            * np.real(
                np.einsum("nk,bn->bk", CoefkPow, self.M13, optimize=self.optipathP13)
            )
        )

    def makeC11(self, CoefsPow, bird):
        """Perform the 11-loop correlation function matrix multiplications"""
        bird.C11 = np.real(
            np.einsum("ns,ln->ls", CoefsPow, self.Mcf11, optimize=self.optipathC11)
        )

    def makeCct(self, CoefsPow, bird):
        """Perform the counterterm correlation function matrix multiplications"""
        bird.Cct = self.co.s**-2 * np.real(
            np.einsum("ns,ln->ls", CoefsPow, self.Mcfct, optimize=self.optipathCct)
        )

    def makeC22(self, CoefsPow, bird):
        """Perform the 22-loop correlation function matrix multiplications"""
        bird.C22 = np.real(
            np.einsum(
                "ns,ms,blnm->lbs",
                CoefsPow,
                CoefsPow,
                self.Mcf22,
                optimize=self.optipathC22,
            )
        )

    def makeC13(self, CoefsPow, bird):
        """Perform the 13-loop correlation function matrix multiplications"""
        bird.C13 = np.real(
            np.einsum(
                "ns,ms,blnm->lbs",
                CoefsPow,
                CoefsPow,
                self.Mcf13,
                optimize=self.optipathC13,
            )
        )

    def Coef(self, bird, window=None):
        """Perform the FFTLog (i.e. calculate the coefficients of the FFTLog) of the input linear power spectrum in the given a Bird().

        Parameters
        ----------
        bird : class
            an object of type Bird()
        """
        return self.fft.Coef(bird.kin, bird.Pin, window=window)

    def Ps(self, bird, window=0.2):
        """Compute the loop power spectrum given a Bird(). Perform the FFTLog and the matrix multiplications.

        Parameters
        ----------
        bird : class
            an object of type Bird()
        """
        coef = self.Coef(bird, window=window)
        coefkPow = self.CoefkPow(coef)
        self.makeP22(coefkPow, bird)
        self.makeP13(coefkPow, bird)

    def Cf(self, bird, window=0.2):
        """Compute the loop correlation function given a Bird(). Perform the FFTLog and the matrix multiplications.

        Parameters
        ----------
        bird : class
            an object of type Bird()
        """
        coef = self.Coef(bird, window=window)
        coefsPow = self.CoefsPow(coef)
        self.makeC11(coefsPow, bird)
        self.makeCct(coefsPow, bird)
        self.makeC22(coefsPow, bird)
        self.makeC13(coefsPow, bird)

    def PsCf(self, bird, window=0.2):
        """Compute the loop power spectrum and correlation function given a Bird(). Perform the FFTLog and the matrix multiplications.

        Parameters
        ----------
        bird : class
            an object of type Bird()
        """
        coef = self.Coef(bird, window=window)
        coefkPow = self.CoefkPow(coef)
        coefsPow = self.CoefsPow(coef)
        self.makeP22(coefkPow, bird)
        self.makeP13(coefkPow, bird)
        self.makeC11(coefsPow, bird)
        self.makeCct(coefsPow, bird)
        self.makeC22(coefsPow, bird)
        self.makeC13(coefsPow, bird)


# TODO: support snapshot
class Resum(object):
    """
    given a Bird() object, performs the IR-resummation of the power spectrum.
    There are two options:
    1.  fullresum: the FFTLog's are performed on the full integrands from s = .1 to s = 10000. in (Mpc/h) (default)
    2. 'optiresum: the FFTLog's are performed only on the BAO peak that is extracted by removing the smooth part of the correlation function. What is left is then padded with zeros and the FFTLog's run from s = .1 to s = 1000. in (Mpc/h).


    Attributes
    ----------
    co : class
        An object of type Common() used to share data
    LambdaIR : float
        Integral cutoff for IR-filters X and Y (fullresum: LambdaIR=.2 (default), optiresum: LambdaIR= 1 ; either value can do for either resummation)
    NIR : float
        Number of IR-correction terms in the sums over n and alpha, where n is the order of the Taylor expansion in powers of k^2 of the exponential of the bulk displacements, and for each n, alpha = { 0, 2 } are the orders of spherical Bessel functions. The ordering of the IR-corrections is given by (n,alpha), where alpha is running faster, e.g. (1, 0), (1, 2), (2, 0), (2, 2), (3, 0), (3, 2), ...
    k2p: ndarray
        powers of k^2
    alllpr : ndarray
        alpha = { 0, 2 } orders of spherical Bessel functions, for each n
    Q : ndarray
        IR-resummation bulk coefficients Q^{ll'}_{||N-j}(n, \alpha, f) of the IR-resummation matrices. f is the growth rate. Computed in method Ps().
    IRcorr : ndarray
        Q-independent pieces in the IR-correction sums over n and alpha of the power spectrum, for bird.which = 'full'. Computed in method Ps().
    IR11 : ndarray
        Q-independent in the IR-correction sums over n and alpha of the power spectrum linear part, for bird.which = 'all'. Computed in method Ps().
    IRct : ndarray
        Q-independent pieces in the IR-correction sums over n and alpha of the power spectrum counterterm, for bird.which = 'all'. Computed in method Ps().
    IRloop : ndarray
        Q-independent loop pieces in the IR-correction sums over n and alpha of the power spectrum loop part, for bird.which = 'all'. Computed in method Ps().
    IRresum : ndarray
        IR-corrections to the power spectrum, for bird.which = 'full'. Computed in method Ps().
    IR11resum : ndarray
        IR-corrections to the power spectrum linear parts, for bird.which = 'all'. Computed in method Ps().
    IRctresum : ndarray
        IR-corrections to the power spectrum counterterms, for bird.which = 'all'. Computed in method Ps().
    IRloopresum : ndarray
        IR-corrections to the power spetrum loop parts, for bird.which = 'all'. Computed in method Ps().
    fftsettings : dict
        Number of points and boundaries of the FFTLog's for the computing the IR-corrections
    fft : class
        An object of type FFTLog() to evaluate the IR-corrections
    M : ndarray
        spherical Bessel transform matrices to evaluate the IR-corrections
    kPow : ndarray
        k's to the powers on which to perform the FFTLog to evaluate the IR-corrections.
    Xfftsettings : dict
        Number of points and boundaries of the FFTLog's for evaluating the IR-filters X and Y
    Xfft : class
        An object of type FFTLog() to evaluate the IR-filters X and Y
    XM : ndarray
        spherical Bessel transform matrices to evaluate the IR-filters X and Y
    XsPow : ndarray
        s's to the powers on which to perform the FFTLog to evaluate the IR-filters X and Y
    """

    def __init__(self, LambdaIR=1.0, NFFT=192, co: Common = common):

        self.co = co

        if self.co.optiresum is True:
            self.LambdaIR = LambdaIR
        else:
            self.LambdaIR = 0.2

        self.NIR = 32 - 4  # legacy

        k2pi = np.array([self.co.kr ** (2 * (p + 1)) for p in range(self.co.NIR)])
        self.k2p = np.concatenate((k2pi, k2pi))

        self.alllpr = [
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],
            [0, 1],  # [0,1], [0,1],
        ]

        # can put those to empty
        self.Q = np.zeros(shape=(2, self.co.Nl, self.co.Nl, self.co.Nn))
        self.IR11 = np.zeros(shape=(self.co.Nl, self.co.Nn, self.co.Nk))
        self.IRct = np.zeros(shape=(self.co.Nl, self.co.Nn, self.co.Nk))
        self.IRloop = np.zeros(
            shape=(self.co.Nl, self.co.Nloop, self.co.Nn, self.co.Nk)
        )

        self.IRresum = np.zeros(shape=(self.co.Nl, self.co.N11, self.co.Nk))
        self.IRctresum = np.zeros(shape=(self.co.Nl, self.co.Nct, self.co.Nk))
        self.IRloopresum = np.zeros(shape=(self.co.Nl, self.co.Nloop, self.co.Nk))

        self.IRcorr = np.zeros(shape=(2, self.co.Nl, self.NIR, self.co.Nkr))

        # keep these to zeros for padding zeros at low k
        self.IRresum = np.zeros(shape=(2, self.co.Nl, self.co.Nk))

        if self.co.optiresum is True:
            self.fftsettings = dict(Nmax=NFFT, xmin=0.1, xmax=1000.0, bias=-0.6)
        else:
            self.fftsettings = dict(Nmax=NFFT, xmin=0.1, xmax=10000.0, bias=-0.6)

        self.fft = FFTLog(**self.fftsettings)
        self.setM()
        self.setkPow()

        self.Xfftsettings = dict(Nmax=32, xmin=1.5e-5, xmax=10.0, bias=-2.6)
        self.Xfft = FFTLog(**self.Xfftsettings)
        self.setXM()
        self.setXsPow()

    def setXsPow(self):
        """Multiply the coefficients with the s's to the powers of the FFTLog to evaluate the IR-filters X and Y."""
        self.XsPow = exp(np.einsum("n,s->ns", -self.Xfft.Pow - 3.0, log(self.co.sr)))

    def setkPow(self):
        """Multiply the coefficients with the k's to the powers of the FFTLog to evaluate the IR-corrections."""
        self.kPow = exp(np.einsum("n,s->ns", -self.fft.Pow - 3.0, log(self.co.kr)))

    def setXM(self):
        """Compute the matrices to evaluate the IR-filters X and Y. Called at instantiation."""
        self.XM = np.empty(shape=(2, self.Xfft.Pow.shape[0]), dtype="complex")
        for l in range(2):
            self.XM[l] = MPC(2 * l, -0.5 * self.Xfft.Pow)

    def IRFilters(self, bird, soffset=1.0, LambdaIR=None, RescaleIR=1.0, window=None):
        """Compute the IR-filters X and Y."""
        if LambdaIR is None:
            LambdaIR = self.LambdaIR
        Coef = self.Xfft.Coef(
            bird.kin,
            bird.Pin * exp(-bird.kin**2 / LambdaIR**2) / bird.kin**2,
            window=window,
        )
        CoefsPow = np.einsum("n,ns->ns", Coef, self.XsPow)
        X02 = np.real(np.einsum("ns,ln->ls", CoefsPow, self.XM))
        X0offset = np.real(
            np.einsum(
                "n,n->",
                np.einsum("n,n->n", Coef, soffset ** (-self.Xfft.Pow - 3.0)),
                self.XM[0],
            )
        )
        X02[0] = X0offset - X02[0]
        X = RescaleIR * 2.0 / 3.0 * (X02[0] - X02[1])
        Y = 2.0 * X02[1]
        return X, Y

    def setM(self):
        """Compute the matrices to evaluate the IR-corrections. Called at instantiation."""
        self.M = np.empty(shape=(self.co.Nl, self.fft.Pow.shape[0]), dtype="complex")
        for l in range(self.co.Nl):
            self.M[l] = 8.0 * pi**3 * MPC(2 * l, -0.5 * self.fft.Pow)

    def IRnWithCoef(self, Coef):
        # CoefkPow = np.einsum("n,nk->nk", Coef, self.kPow)
        # return np.real(np.einsum("nk,ln->lk", CoefkPow, self.M[: self.co.Na]))
        # precomputed np.einsum_path does not improve the performance
        return np.real(self.M[: self.co.Na] @ (Coef[:, newaxis] * self.kPow))

    def makeQ(self, f):
        """Compute the bulk coefficients Q^{ll'}_{||N-j}(n, \alpha, f)"""
        for a in range(2):
            for l in range(self.co.Nl):
                for lpr in range(self.co.Nl):
                    for u in range(self.co.Nn):
                        if self.co.NIR == 8:
                            self.Q[a][l][lpr][u] = Qa[1 - a][2 * l][2 * lpr][u](f)
                        elif self.co.NIR == 16:
                            self.Q[a][l][lpr][u] = Qawithhex[1 - a][2 * l][2 * lpr][u](
                                f
                            )
                        elif self.co.NIR == 20:
                            raise NotImplementedError
                        else:
                            raise ValueError(f"unexpected co.NIR == {self.co.NIR}")

    def extractBAO(self, cf):
        """Given a correlation function cf,
        - if fullresum, return cf
        - if optiresum, extract the BAO peak"""
        if not self.co.optiresum:
            return cf

        cfnobao = np.concatenate(
            [cf[..., : self.co.idlow], cf[..., self.co.idhigh :]], axis=-1
        )
        nobao = (
            interp1d(
                self.co.snobao,
                self.co.snobao**2 * cfnobao,
                kind="linear",
                axis=-1,
            )(self.co.sbao)
            * self.co.sbao**-2
        )
        bao = cf[..., self.co.idlow : self.co.idhigh] - nobao
        return bao

    def setXpYp(self, bird):
        X, Y = self.IRFilters(bird)
        Xp = np.array([X ** (p + 1) for p in range(self.co.NIR)])
        XpY = np.array([Y * X**p for p in range(self.co.NIR)])
        XpYp = np.concatenate((Xp, XpY))
        return XpYp

    def precomputedCoef(self, XpYp: NDArray, Carray: NDArray, window=None) -> NDArray:
        input = np.einsum("jk,...k->...jk", XpYp, Carray)
        return self.fft.Coef(self.co.sr, input, extrap="padding", window=window)

    def Ps(self, bird: Bird, window=None):
        """This is the main method of the class. Compute the IR-corrections."""
        self.makeQ(bird.f)

        XpYp = self.setXpYp(bird)

        extracted_C11 = self.extractBAO(bird.C11)
        CoefArray = self.precomputedCoef(XpYp, extracted_C11, window=window)
        # TODO: unroll the loop
        for l, cl in enumerate(extracted_C11):
            for j, xy in enumerate(XpYp):
                IRcorrUnsorted = self.k2p[j] * self.IRnWithCoef(CoefArray[l, j, :])
                for v in range(self.co.Na):
                    self.IR11[l, j * self.co.Na + v, self.co.Nklow :] = IRcorrUnsorted[
                        v
                    ]
        extracted_Cct = self.extractBAO(bird.Cct)
        CoefArray = self.precomputedCoef(XpYp, extracted_Cct, window=window)
        for l, cl in enumerate(extracted_Cct):
            for j, xy in enumerate(XpYp):
                IRcorrUnsorted = self.k2p[j] * self.IRnWithCoef(CoefArray[l, j, :])
                for v in range(self.co.Na):
                    self.IRct[l, j * self.co.Na + v, self.co.Nklow :] = IRcorrUnsorted[
                        v
                    ]
        extracted_Cloopl = self.extractBAO(bird.Cloopl)
        CoefArray = self.precomputedCoef(XpYp, extracted_Cloopl, window=window)
        for l, cl in enumerate(extracted_Cloopl):
            for i, cli in enumerate(cl):
                for j, xy in enumerate(XpYp):
                    IRcorrUnsorted = self.k2p[j] * self.IRnWithCoef(
                        CoefArray[l, i, j, :]
                    )
                    for v in range(self.co.Na):
                        self.IRloop[
                            l, i, j * self.co.Na + v, self.co.Nklow :
                        ] = IRcorrUnsorted[v]
        self.IR11resum = np.einsum("lpn,pnk,pi->lik", self.Q[0], self.IR11, self.co.l11)
        self.IRctresum = np.einsum("lpn,pnk,pi->lik", self.Q[1], self.IRct, self.co.lct)
        self.IRloopresum = np.einsum("lpn,pink->lik", self.Q[1], self.IRloop)
        bird.P11l += self.IR11resum
        bird.Pctl += self.IRctresum
        bird.Ploopl += self.IRloopresum


def window_kgrid(kmax: float = 0.3, accboost: int = 1) -> NDArray:
    return np.concatenate(
        [
            np.geomspace(1e-5, 0.015, 100 * accboost, endpoint=False),
            np.arange(0.015, kmax, 1e-3 / accboost),
        ]
    )


class MetaInfoError(Exception):
    pass


Location = Union[str, Path]


class Window(HasLogger):
    R"""Window effect

    Parameters
    ----------
    window_fourier_file: str | Path
        path to fourier transformed window matrix
        default None: always recompute the window and will not save to disk
    window_configspace_file: str | Path
        path to configspace window file, the header should be s, Q0, Q2, Q4, ...
        default None: load fourier matrix from disk
    co: Common
        this class only uses co.k and co.Nk, if Na, Nl not specified, use co.Nl
        default pybird.Common
    load: bool
        set it True to load fourier matrix from disk, default True
    save: bool
        set it True to save fourier matrix to disk, default True
    check_meta: bool
        set it True to check meta info when loading fourier matrix, default True
        if meta info not exists, report deprecated warning (will raise Exception in the future),
        if meta info not match, raise MetaInfoError
    Na: int
        output multipoles, default co.Nl
    Nl: int
        input multipoles, default co.Nl
    Nq: int
        use Nq Qs, default 3, i.e. use Q0, Q2, Q4
    pmax: float, default 0.3
        integrate window up to pmax
    accboost: int
        accboost x number of p grids, default 1
    withmask: bool
        set it True to mask window, default True
    windowk: float
        mask width, default 0.05, i.e. when k=0.1, only p in [0.1 - 0.05, 0.1 + 0.05] will be integrated
    Nmax: int
        FFTLog nodes, default 4096
    xmin_factor: float
        FFTLog xmin = smin * xmin_factor, where smin is determined by window_configspace_file
        default xmin_factor = 1.0
    xmax_factor: float
        FFTLog xmax = smax * xmax_factor, where smax is determined by window_configspace_file
        default xmax_factor = 100.
    bias: float
        FFTLog bias, default -1.6
    window_param: float | None
        FFTLog window parameter, default 1
    window_st: bool
        set it True to apply window effect to stochastic terms
    name: str
        logger name, default 'pybird.window'
    snapshot: bool
        take snapshot after applying ``window``, by default False

    Notes
    -----
    ds in mask file should be small enough because the value will be multiplied by a spherical
    bessel function and then will be interpolated

    Math
    ----
    window convolution

    ..math:: P'_a(k) = \sum_{l}\int dp W(k, p)_{a, l}P_l(p)

    window

    ..math:: W(k, p)_{a, l} = \frac{2}{\pi}(-i)^a i^l p^2 \int ds s^2 j_{a}(ks)Q_{a,l}(s)j_l(ps)

    configspace window

    ..math:: Q_{a, l}(s) = \sum_{q}C_{a,l,q}Q_q(s)

    coef

    ..math:: C_{\ell, \ell^{\prime}, \ell^{\prime \prime}} \equiv(2 \ell+1)\left(\begin{array}{ccc}\ell & \ell^{\prime} & \ell^{\prime \prime} \\ 0 & 0 & 0\end{array}\right)^{2}
    """

    def __init__(
        self,
        window_fourier_file: Location | None = None,
        window_configspace_file: Location | None = None,
        co: Common = common,
        load: bool = True,
        save: bool = True,
        check_meta: bool = True,
        Na: int | None = None,
        Nl: int | None = None,
        Nq: int | None = 3,
        pmax: float = 0.3,
        accboost: int = 1,
        withmask: bool = True,
        windowk: float = 0.05,
        Nmax: int = 4096,
        xmin_factor: float = 1.0,
        xmax_factor: float = 100.0,
        bias: float = -1.6,
        window_param: float | None = 1,
        window_st: bool = True,
        name: str = "pybird.window",
        snapshot: bool = False,
    ) -> None:
        self.set_logger(name=name)
        self.co: Common = co
        if window_fourier_file is None and window_configspace_file is None:
            raise ValueError(
                "Window requires window_fourier_file "
                "or window_configspace_file or both"
            )
        self.window_fourier_file = (
            Path(window_fourier_file).resolve() if window_fourier_file else None
        )
        self.window_configspace_file = (
            Path(window_configspace_file).resolve() if window_configspace_file else None
        )
        window_configspace_file_str = None
        if self.window_configspace_file:
            window_configspace_file_str = str(self.window_configspace_file)
        self._load = load
        self._save = save if self.window_fourier_file else False
        self.check_meta = check_meta
        self._create_meta = True
        self.window_st = window_st
        self.withmask = withmask
        self.windowk = windowk
        Na = Na if Na else self.co.Nl
        Nl = Nl if Nl else self.co.Nl
        if Na > self.co.Nl or Nl > self.co.Nl:
            raise ValueError(
                f"request Na={Na}, Nl={Nl} "
                f"while bird only compute Nl up to {self.co.Nl}"
            )
        if Na > Nl:
            raise ValueError(f"dangerous settings Na={Na}, Nl={Nl}")
        self.p = window_kgrid(kmax=pmax, accboost=accboost)
        self.meta: dict[str, Any] = dict(
            Na=Na,
            Nl=Nl,
            Nq=Nq,
            pmax=pmax,
            accboost=accboost,
            Nmax=Nmax,
            xmin_factor=xmin_factor,
            xmax_factor=xmax_factor,
            bias=bias,
            window_param=window_param,
            window_configspace_file=window_configspace_file_str,
            k=self.co.k.tolist(),
        )
        self.Wal = self._load_Wal()  # type: ignore
        if self.Wal is None:
            self.Wal: NDArray = self._compute_Wal()
        self.Waldk: NDArray = self._compute_Waldk()  # mask settings not in meta
        if self._save:
            self._save_Wal()
        self.snapshot = snapshot
        if self.snapshot:
            self.mpi_info("snapshot is enabled")

    def _load_Wal(self):
        """load fourier matrix, return None if failed"""
        Wal = None
        window_fourier_file = self.window_fourier_file
        if self._load:
            try:
                Wal = np.load(window_fourier_file)  # type: ignore
                self.mpi_info("Loaded mask: %s", window_fourier_file)
            except (OSError, TypeError):
                self.mpi_warning("Cannot load mask: %s", window_fourier_file)
            else:
                # retry: Backward Compatibility
                # automatically recompute if Nl not match
                if Wal.shape[1] != self.meta["Nl"]:
                    Wal = None
                    self.mpi_info(
                        "Nl not match, load the one with suffix '_Nl%d'",
                        self.meta["Nl"],
                    )
                    assert window_fourier_file
                    self.window_fourier_file = replace_suffix(
                        window_fourier_file, f'_Nl{self.meta["Nl"]}.npy'
                    )
                    window_fourier_file = self.window_fourier_file
                    try:
                        Wal = np.load(window_fourier_file)
                        self.mpi_info("Loaded mask: %s", window_fourier_file)
                    except OSError:
                        self.mpi_warning("Cannot load mask: %s", window_fourier_file)
            if (Wal is not None) and self.check_meta:
                assert window_fourier_file
                meta_file = replace_suffix(window_fourier_file, ".json")
                if not meta_file.exists():
                    self.mpi_warning(
                        "Deprecated: when check_meta=True and load=True, "
                        "Window will try to find the meta-info json file and "
                        "compare it to current settings. In the future, "
                        "if the meta-info file does not exist, "
                        "Exception will be raised."
                    )
                    self._create_meta = False
                else:
                    with meta_file.open("r") as f:
                        meta = json.load(f)
                    # copy meta info from previous file
                    if self.meta["window_configspace_file"] is None:
                        self.meta["window_configspace_file"] = meta[
                            "window_configspace_file"
                        ]
                    if meta != self.meta:
                        raise MetaInfoError(
                            f"inconsistent meta info\n"
                            f"loaded matrix's meta:\n{meta}\n"
                            f"expect:\n{self.meta}"
                        )
        if Wal is not None:
            self._save = False

        return Wal

    def _compute_Wal(self):
        self.mpi_info("Computing new mask")
        self.mpi_warning(
            "please manually check the fourier matrix after computation, "
            "since the default FFTLog settings may not be optimal"
        )
        Na, Nl, Nq = [cast(int, self.meta[x]) for x in ("Na", "Nl", "Nq")]
        if self.window_configspace_file is None:
            raise ValueError("please specify a configuration space mask file")

        try:
            swindow_config_space = np.loadtxt(self.window_configspace_file)
            # remove s=0
            while swindow_config_space[0, 0] == 0.0:
                swindow_config_space = swindow_config_space[1:, :]
            # keep Q0, Q2, ... (Nq) only
            if swindow_config_space.shape[-1] > (1 + Nq):
                swindow_config_space = swindow_config_space[:, : 1 + Nq]
        except OSError as ex:
            raise OSError(
                f"Error: can't load mask file: " f"{self.window_configspace_file}"
            )
        except IndexError as ex:
            raise TypeError(f"loaded config-space mask has unexpected shape") from ex

        # fmt: off
        Calq = np.array([
            [[     1,      0,        0,        0],
             [     0,    1/5,        0,        0],
             [     0,      0,      1/9,        0],
             [     0,      0,        0,     1/13]],
            [[     0,      1,        0,        0],
             [     1,    2/7,      2/7,        0],
             [     0,    2/7,  100/693,   25/143],
             [     0,      0,   25/143,   14/143]],
            [[     0,      0,        1,        0],
             [     0,  18/35,    20/77,   45/143],
             [     1,  20/77, 162/1001,   20/143],
             [     0, 45/143,   20/143, 252/2431]],
            [[     0,      0,        0,        1],
             [     0,      0,     5/11,    14/55],
             [     0,   5/11,    20/99,   28/187],
             [     1,  14/55,   28/187, 400/3553]],
        ])[..., :Nq]
        # fmt: on

        sw = swindow_config_space[:, 0]
        Qq = swindow_config_space[:, 1:].T
        Qal = np.einsum("alq,qs->als", Calq, Qq)[:Na, :Nl, :]

        self.fftsettings = dict(
            Nmax=self.meta["Nmax"],
            xmin=sw[0] * self.meta["xmin_factor"],
            xmax=sw[-1] * self.meta["xmax_factor"],
            bias=self.meta["bias"],
        )  # 1e-2 - 1e6 [Mpc/h]
        self.fft = FFTLog(**self.fftsettings)
        self.pPow = exp(np.einsum("n,p->np", -self.fft.Pow - 3.0, log(self.p)))
        self.M = np.empty(shape=(Nl, self.fft.Pow.shape[0]), dtype="complex")
        for l in range(Nl):
            self.M[l] = 4 * pi * MPC(2 * l, -0.5 * self.fft.Pow)

        self.Coef = np.empty(
            shape=(Na, Nl, self.co.Nk, self.fft.Pow.shape[0]),
            dtype="complex",
        )
        Nas = np.arange(Na)
        Nls = np.arange(Nl)
        self.Coef[...] = (
            (-1j) ** (2 * Nas)[:, newaxis, newaxis, newaxis]
            * (1j) ** (2 * Nls)[newaxis, :, newaxis, newaxis]
            * self.fft.Coef(
                sw,
                Qal[:, :, newaxis, :]
                * spherical_jn(
                    2 * Nas[:, newaxis, newaxis, newaxis],
                    sw[newaxis, newaxis, newaxis, :]
                    * self.co.k[newaxis, newaxis, :, newaxis],
                ),
                window=self.meta["window_param"],
                extrap="padding",
            )
        )

        Wal = self.p**2 * np.real(
            np.einsum("alkn,np,ln->alkp", self.Coef, self.pPow, self.M)
        )

        return Wal

    def _compute_Waldk(self):
        # Apply masking centered around the value of k
        Wal_masked = self.Wal
        if self.withmask:
            kpgrid, kgrid = np.meshgrid(self.p, self.co.k, indexing="ij")
            mask = (kpgrid < kgrid + self.windowk) & (kpgrid > kgrid - self.windowk)
            Wal_masked = np.einsum("alkp,pk->alkp", self.Wal, mask)

        # the spacing (need to do the convolution as a sum)
        deltap = self.p[1:] - self.p[:-1]  # type: ignore
        deltap = np.concatenate([[0], deltap])
        return np.einsum("alkp,p->alkp", Wal_masked, deltap)

    @root_only
    def _save_Wal(self):
        assert self.window_fourier_file
        self.mpi_info("Saving mask: %s", self.window_fourier_file)
        np.save(self.window_fourier_file, self.Wal)
        if self._create_meta:
            meta_file = replace_suffix(self.window_fourier_file, ".json")
            with meta_file.open("w") as f:
                json.dump(self.meta, f, indent=2)

    def integrWindow(self, P, interp=True):
        """
        Convolve the window functions to a power spectrum P
        """
        if interp:
            Pk = interp1d(
                self.co.k,
                P,
                axis=-1,
                kind="cubic",
                bounds_error=False,
                fill_value="extrapolate",
            )(self.p)
        else:
            Pk = P
        # (multipole l, multipole ' p, k, k' m) , (multipole ', power pectra s, k' m)
        return np.einsum("alkp,lsp->ask", self.Waldk, Pk, optimize=True)

    def Window(self, bird: Bird):
        """
        Apply the survey window function to the bird power spectrum
        """
        bird.P11l = self.integrWindow(bird.P11l)
        bird.Pctl = self.integrWindow(bird.Pctl)
        bird.Ploopl = self.integrWindow(bird.Ploopl)
        if self.window_st:
            bird.setPstl(self.p)
            bird.Pstl = self.integrWindow(bird.Pstl, interp=False)
        if self.snapshot:
            bird.create_snapshot("window")


class APeffect(HasLogger):
    """AP effect

    Parameters
    ----------
    Om_AP: float, optional
        omega matter for fiducial cosmology
    z_AP: float, optional
        fiducial effective redshift
    rdrag_AP: float, optional
        fiducial rdrag, in absolute units
    h_AP: float, optional
        fiducial h, used together with rdrag_AP,
        rdrag_AP and h_AP are only used in ``get_alperp_alpara``
    DA: float, optional
        fiducial DA
    H: float, optional
        fiducial H
    nbinsmu: int
        mu bins in [0, 1], default 200
    accboost: int
        boost the accuracy, default 1
    Nlmax: int, optional
        approximate Pkmu using Nlmax multipoles, default self.co.Nl
    co: Common
        this class only uses co.k and co.Nl, default pybird.Common
    name: str
        logger name, default 'pybird.apeffect'
    snapshot: bool
        take a snapshot after applying ``AP``, by default False

    Methods
    -------
    AP(bird, q=None): apply APeffect
    """

    def __init__(
        self,
        Om_AP: float | None = None,
        z_AP: float | None = None,
        DA: float | None = None,
        H: float | None = None,
        rdrag_AP: float | None = None,
        h_AP: float | None = None,
        nbinsmu: int = 200,
        accboost: int = 1,
        Nlmax: int | None = None,
        co: Common = common,
        name: str = "pybird.apeffect",
        snapshot: bool = False,
    ):
        self.set_logger(name=name)
        self.co = co
        if (DA is not None) and (H is not None):
            self.DA, self.H = DA, H
        elif (Om_AP is not None) and (z_AP is not None):
            self.mpi_warning("DA and H not given, compute using Om_AP and z_AP instead")
            self.mpi_info("Om_AP=%.5f, z_AP=%.5f", Om_AP, z_AP)
            self.DA: float = DAfunc(Om_AP, z_AP)
            self.H: float = Hubble(Om_AP, z_AP)
        else:
            raise ValueError("expect input params: Om_AP and z_AP, or DA and H")

        self.rdrag_AP = rdrag_AP
        self.h_AP = h_AP
        if (self.rdrag_AP is not None) and (self.h_AP is not None):
            self.mpi_info("fidudial rdrag=%.2f, h=%.4f", self.rdrag_AP, self.h_AP)
        self._rdrag_warned = False

        self.nbinsmu = accboost * nbinsmu
        self.muacc = np.linspace(0, 1, self.nbinsmu)
        self.kgrid, self.mugrid = np.meshgrid(self.co.k, self.muacc, indexing="ij")
        self.Nlmax = self.Nlmax if Nlmax else self.co.Nl
        if self.Nlmax > self.co.Nl:
            raise ValueError(
                f"request Nlmax={self.Nlmax}, "
                f"while bird only compute Nl up to {self.co.Nl}"
            )
        self.arrayLegendremugrid = np.array(
            [
                (2 * l + 1) / 2.0 * legendre(l)(self.mugrid)
                for l in 2 * np.arange(self.Nlmax)
            ]
        )
        self.logstate()
        self.snapshot = snapshot
        if self.snapshot:
            self.mpi_info("snapshot is enabled")

    def get_AP_param(self, bird):
        """
        Compute the AP parameters
        """
        # TODO: the definition of DA includes 1/(1+z),
        # but typically alperp is defined without this factor, need investigation
        qperp = bird.DA / self.DA
        qpar = self.H / bird.H
        return qperp, qpar

    def get_alperp_alpara(self, bird):
        """
        Compute the alperp and alpara
        """
        if any(x is None for x in (self.rdrag_AP, self.h_AP, bird.rdrag, bird.h)):
            if not self._rdrag_warned:
                self.mpi_warning(
                    "rdrag_AP or h_AP or bird.rdrag or bird.h not given, "
                    "fallback to qperp and qpara"
                )
                self._rdrag_warned = True
            return self.get_AP_param(bird)
        ratio = (self.rdrag_AP * self.h_AP) / (bird.rdrag * bird.h)  # type: ignore
        alperp = bird.DA / self.DA * ratio
        alpara = self.H / bird.H * ratio
        return alperp, alpara

    def integrAP(self, Pk, kp, arrayLegendremup):
        """
        AP integration
        Credit: Jerome Gleyzes
        """
        Pkint = interp1d(
            self.co.k,
            Pk,
            axis=-1,
            kind="cubic",
            bounds_error=False,
            fill_value="extrapolate",
        )(kp)
        Pkmu = np.einsum("lpkm,lkm->pkm", Pkint, arrayLegendremup, optimize=True)
        Integrandmu = np.einsum(
            "pkm,lkm->lpkm", Pkmu, self.arrayLegendremugrid, optimize=True
        )
        return 2 * np.trapz(Integrandmu, x=self.mugrid, axis=-1)

    def AP(self, bird: Bird, q=None):
        """
        Apply the AP effect to the bird power spectrum
        Credit: Jerome Gleyzes
        """
        if q is None:
            qperp, qpar = self.get_AP_param(bird)
        else:
            qperp, qpar = q
        F = qpar / qperp
        kp = self.kgrid / qperp * (1 + self.mugrid**2 * (F**-2 - 1)) ** 0.5
        mup = self.mugrid / F * (1 + self.mugrid**2 * (F**-2 - 1)) ** -0.5
        arrayLegendremup = np.array([legendre(2 * i)(mup) for i in range(self.Nlmax)])
        coef = 1.0 / (qperp**2 * qpar)

        # no effect on bird.Pstl, since the AP effect can be absorbed into coefficients
        bird.P11l = coef * self.integrAP(bird.P11l, kp, arrayLegendremup)
        bird.Pctl = coef * self.integrAP(bird.Pctl, kp, arrayLegendremup)
        bird.Ploopl = coef * self.integrAP(bird.Ploopl, kp, arrayLegendremup)
        if self.snapshot:
            bird.create_snapshot("APeffect")

    def logstate(self):
        self.mpi_info("fiducial DA=%.5f, H=%.5f", self.DA, self.H)
        self.mpi_info("nbinsmu=%d", self.nbinsmu)
        self.mpi_info("Nlmax=%d", self.Nlmax)


class FiberCollision(HasLogger):
    """Fiber Collision correction

    Parameters
    ----------
    fs: float
        fraction of the survey affected by fiber collisions, default 0.6
    Dfc: float
        angular distance of the fiber channel, default Dfc(z = 0.55) = 0.43 / 0.6777 Mpc/h
    ktrust: float
        a UV cutoff, default 0.25
    co: Common
        this class only uses co.k and co.Nl, default pybird.Common
    name: str
        logger name, by default 'pybird.fiber'
    snapshot: bool
        take a snapshot after applying ``fibcolWindow``, by default False
    """

    def __init__(
        self,
        fs: float,
        Dfc: float,  # = 0.43 / 0.6777,
        ktrust: float = 0.25,
        co: Common = common,
        name: str = "pybird.fiber",
        snapshot: bool = False,
    ) -> None:
        self.set_logger(name=name)
        self.ktrust = ktrust
        self.fs = fs
        self.Dfc = Dfc
        self.co = co
        self.mpi_info("Apply fiber collision correction")
        self.mpi_info("ktrust: %.3f", self.ktrust)
        self.mpi_info("fs: %.3f", self.fs)
        self.mpi_info("Dfc: %.3f", self.Dfc)
        self.snapshot = snapshot
        if self.snapshot:
            self.mpi_info("snapshot is enabled")

    def dPuncorr(self, kout, fs=0.6, Dfc=0.43 / 0.6777):
        """
        Compute the uncorrelated contribution of fiber collisions

        kout : a cbird wavenumber output, typically a (39,) np array
        fs : fraction of the survey affected by fiber collisions
        Dfc : angular distance of the fiber channel Dfc(z = 0.55) = 0.43Mpc

        Credit: Thomas Colas
        """
        dPunc = np.zeros((3, len(kout)))
        for l in [0, 2, 4]:
            dPunc[int(l / 2)] = (
                -fs
                * pi
                * Dfc**2.0
                * (2.0 * pi / kout)
                * (2.0 * l + 1.0)
                / 2.0
                * special.legendre(l)(0)
                * (1.0 - (kout * Dfc) ** 2 / 8.0)
            )
        return dPunc

    def dPcorr(self, kout, kPS, PS, ktrust=0.25, fs=0.6, Dfc=0.43 / 0.6777):
        """
        Compute the correlated contribution of fiber collisions

        kPS : a cbird wavenumber output, typically a (39,) np array
        PS : a cbird power spectrum output, typically a (3, 39) np array
        ktrust : a UV cutoff
        fs : fraction of the survey affected by fiber collisions
        Dfc : angular distance of the fiber channel Dfc(z = 0.55) = 0.43Mpc

        Credit: Thomas Colas
        """
        q_ref = np.geomspace(min(kPS), ktrust, num=1024)
        # create log bin
        dq_ref = q_ref[1:] - q_ref[:-1]  # type: ignore
        dq_ref = np.concatenate([[0], dq_ref])

        PS_interp = interp1d(
            kPS, PS, axis=-1, bounds_error=False, fill_value="extrapolate"
        )(q_ref)

        dPcorr = np.zeros(shape=(PS.shape[0], PS.shape[1], len(kout)))
        for j in range(PS.shape[1]):
            for l in range(self.co.Nl):
                for lp in range(self.co.Nl):
                    for i, k in enumerate(kout):
                        if lp <= l:
                            maskIR = q_ref < k
                            dPcorr[l, j, i] += (
                                -0.5
                                * fs
                                * Dfc**2
                                * np.einsum(
                                    "q,q,q,q->",
                                    q_ref[maskIR],
                                    dq_ref[maskIR],
                                    PS_interp[lp, j, maskIR],
                                    fllp_IR(2 * l, 2 * lp, k, q_ref[maskIR], Dfc),
                                )
                            )
                        if lp >= l:
                            maskUV = (q_ref > k) & (q_ref < ktrust)
                            dPcorr[l, j, i] += (
                                -0.5
                                * fs
                                * Dfc**2
                                * np.einsum(
                                    "q,q,q,q->",
                                    q_ref[maskUV],
                                    dq_ref[maskUV],
                                    PS_interp[lp, j, maskUV],
                                    fllp_UV(2 * l, 2 * lp, k, q_ref[maskUV], Dfc),
                                )
                            )
        return dPcorr

    # TODO: stochastic terms? uncorrelated contribution?
    def fibcolWindow(self, bird: Bird):
        """
        Apply window effective method correction to fiber collisions to the bird power spectrum
        """
        ktrust, fs, Dfc = self.ktrust, self.fs, self.Dfc
        bird.P11l += self.dPcorr(
            self.co.k,
            self.co.k,
            bird.P11l,
            ktrust=ktrust,
            fs=fs,
            Dfc=Dfc,
        )
        bird.Pctl += self.dPcorr(
            self.co.k,
            self.co.k,
            bird.Pctl,
            ktrust=ktrust,
            fs=fs,
            Dfc=Dfc,
        )
        bird.Ploopl += self.dPcorr(
            self.co.k,
            self.co.k,
            bird.Ploopl,
            ktrust=ktrust,
            fs=fs,
            Dfc=Dfc,
        )
        if self.snapshot:
            bird.create_snapshot("fiber")
